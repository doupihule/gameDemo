






ChooseTrigger = class('ChooseTrigger')
function ChooseTrigger.chooseNearRole(targetRole, instanceArr)
  local resultRole = nil
  local targetDis = 0
  local i = 0
  repeat
    local role2 = instanceArr[i+1]
    local dis = math.abs(role2.pos.x - targetRole.pos.x)
    if not resultRole then
      resultRole = role2
      targetDis = dis
    else
      if dis < targetDis then
        resultRole = role2
        targetDis = dis
      end
    end
    i=i+1
  until not(i < #instanceArr)
  return resultRole
end

function ChooseTrigger.chooseAbsNearRole(targetInstance, instanceArr, excludeArr, extraDis)
  if excludeArr == nil then
    excludeArr=nil
  end
  if extraDis == nil then
    extraDis=0
  end
  local resultRole = nil
  local targetDis = 0
  local i = 0
  repeat
    repeat
      local role2 = instanceArr[i+1]
      if excludeArr and excludeArr:find(role2) ~= -1 then
        break
      end
      local dis = ChooseTrigger.getPowerDis(role2.pos, targetInstance.pos)
      if not resultRole then
        resultRole = role2
        targetDis = dis
      else
        if dis < targetDis then
          resultRole = role2
          targetDis = dis
        end
      end
      if extraDis and targetDis > extraDis * extraDis then
        resultRole = nil
      end
    until true
    i=i+1
  until not(i < #instanceArr)
  return resultRole
end

function ChooseTrigger.getRoleByType(targetRole, type, compareValue, out)
  if type == 1 then
    table.insert(out, targetRole)
  elseif type == 2 then
    local campArr = targetRole.campArr
    local i = 0
    repeat
      table.insert(out, campArr[i+1])
      i=i+1
    until not(i < #campArr)
  elseif type == 3 or type == 4 then
    if type == 3 then
      compareValue = BattleConst.POSTYPE_QIANPAI
    else
      compareValue = BattleConst.POSTYPE_HOUPAI
    end
    local campArr = targetRole.campArr
    local i = 0
    repeat
      local instance = campArr[i+1]
      if instance.posType == compareValue then
        table.insert(out, instance)
      end
      i=i+1
    until not(i < #campArr)
  elseif type == 5 then
    local campArr = targetRole.campArr
    local i = 0
    repeat
      local instance = campArr[i+1]
      if instance.dataId == compareValue then
        table.insert(out, instance)
      end
      i=i+1
    until not(i < #campArr)
  end
  return out
end

function ChooseTrigger.getPowerDis(p1, p2)
  local dx = p1.x - p2.x
  local dz = p1.z - p2.z
  return dx * dx + dz * dz
end

function ChooseTrigger.chooseSkillToOut(targetRole, out)
  local skill = nil
  local tempArr = nil
  out[0+1] = -2
  if (targetRole.isAutoSKill and targetRole.energy == targetRole.maxEnergy) and targetRole.energySkill then
    skill = targetRole.energySkill
    tempArr = ChooseTrigger._initSkillChoose(targetRole, skill)
    if #tempArr > 0 then
      out[0+1] = 0
      out[1+1] = skill
      return
    else
      out[0+1] = -1
      out[1+1] = skill
    end
  end
  if targetRole.ctrlBuffBit & BuffTrigger.buff_logical_chenmo then
    BattleLogsManager.battleEcho("id:", targetRole.dataId, "_被沉默了.释放普攻")
    -- [ts2lua]targetRole.normalSkills下标访问可能不正确
    skill = targetRole.normalSkills[#targetRole.normalSkills - 1]
    tempArr = ChooseTrigger._initSkillChoose(targetRole, skill)
    if #tempArr > 0 then
      out[0+1] = 0
      out[1+1] = skill
      return
    end
  end
  local i = 0
  repeat
    skill = targetRole.normalSkills[i+1]
    if skill.isActive and skill.leftSkillCd <= 0 then
      tempArr = ChooseTrigger._initSkillChoose(targetRole, skill)
      if #tempArr > 0 then
        out[0+1] = 0
        out[1+1] = skill
        return skill
      else
        out[0+1] = -1
        out[1+1] = skill
      end
    end
    i=i+1
  until not(i < #targetRole.normalSkills)
  if out[0+1] == -2 then
    out[0+1] = -1
    -- [ts2lua]targetRole.normalSkills下标访问可能不正确
    out[1+1] = targetRole.normalSkills[#targetRole.normalSkills - 1]
    ChooseTrigger._initSkillChoose(targetRole, out[1+1])
  end
  return
end

function ChooseTrigger.getIsCanUseSkill(targetRole, skill, out)
  local tempArr = {}
  if skill.isActive and skill.leftSkillCd <= 0 then
    tempArr = ChooseTrigger._initSkillChoose(targetRole, skill)
    if #tempArr > 0 then
      out[0+1] = 0
      out[1+1] = skill
    else
      out[0+1] = -1
      out[1+1] = skill
    end
  end
end

function ChooseTrigger._initSkillChoose(targetRole, skill)
  local tempArr = skill.tempChooseArr
  -- [ts2lua]修改数组长度需要手动处理。
  tempArr.length = 0
  ChooseTrigger.getSkillTargetRole(targetRole, skill, skill.chooseTartgetCfg, tempArr)
  return tempArr
end

ChooseTrigger.RANGE_CIRCLE = 1;
ChooseTrigger.RANGE_RECT = 2;
ChooseTrigger.RANGE_SECTOR = 3;
ChooseTrigger.RANGE_FULLSCREEN = 4;
ChooseTrigger.choose_self = 0;
ChooseTrigger.choose_selfcamp = 1;
ChooseTrigger.choose_tocamp = 2;
ChooseTrigger.choose_summoned = 3;
ChooseTrigger.choose_campoutself = 4;
ChooseTrigger.choose_hitself = 5;
ChooseTrigger.choose_campwithdied = 11;
function ChooseTrigger.getSkillTargetRole(instance, skill, targetData, out, usedDisInstance, soucePos, outArea)
  if usedDisInstance == nil then
    usedDisInstance=nil
  end
  if soucePos == nil then
    soucePos=nil
  end
  if outArea == nil then
    outArea=false
  end
  local rangeType = targetData.targetRange
  local chooseType = targetData.targetGroup
  local targetArr = nil
  if not usedDisInstance then
    usedDisInstance = instance
  end
  local tempArr = nil
  local targetNumber = targetData.targetNumber
  -- [ts2lua]修改数组长度需要手动处理。
  out.length = 0
  if chooseType == ChooseTrigger.choose_self then
    table.insert(out, instance)
    return out
  elseif chooseType == ChooseTrigger.choose_selfcamp then
    targetArr = instance.campArr
  elseif chooseType == ChooseTrigger.choose_tocamp then
    targetArr = instance.toCampArr
    local betauntTarget = instance.beTauntTargetInfo.target
    if betauntTarget then
      if betauntTarget.hp == 0 then
        if instance.beTauntTargetInfo.buff then
          instance:clearOneBuff(instance.beTauntTargetInfo.buff)
        end
      else
        if targetNumber == 1 then
          tempArr = BattleFunc.getOneTempArr()
          table.insert(tempArr, betauntTarget)
          targetArr = tempArr
        end
      end
    end
  elseif chooseType == ChooseTrigger.choose_campoutself then
    tempArr = BattleFunc.getOneTempArr()
    local i = 0
    repeat
      local tempInstance = instance.campArr[i+1]
      if tempInstance ~= instance then
        table.insert(tempArr, tempInstance)
      end
      i=i+1
    until not(i < #instance.campArr - 1)
    targetArr = tempArr
  elseif chooseType == ChooseTrigger.choose_campwithdied then
    tempArr = BattleFunc.getOneTempArr()
    if #instance.diedArr > 0 then
      local i = 0
      repeat
        local tempInstance = instance.campArr[i+1]
        table.insert(tempArr, tempInstance)
        i=i+1
      until not(i < #instance.campArr)
      local i = 0
      repeat
        local tempInstance = instance.diedArr[i+1]
        table.insert(tempArr, tempInstance)
        i=i+1
      until not(i < #instance.diedArr)
      targetArr = tempArr
    else
      targetArr = instance.campArr
    end
  elseif chooseType == ChooseTrigger.choose_hitself then
    tempArr = BattleFunc.getOneTempArr()
    if instance.tempBeUsedValue and instance.tempBeUsedValue[2+1] then
      table.insert(tempArr, instance.tempBeUsedValue[2+1])
    end
    targetArr = tempArr
  end
  if not soucePos then
    soucePos = instance.pos
  end
  local rangeParams = targetData.rangeParams
  if not outArea then
    if rangeType == ChooseTrigger.RANGE_CIRCLE or rangeType == ChooseTrigger.RANGE_SECTOR then
      ChooseTrigger.chooseRoleByCircle(usedDisInstance, rangeParams[0+1], rangeParams[1+1], rangeParams[2+1], targetArr, -1, out, nil, rangeParams[3+1] or 360, soucePos)
    elseif rangeType == ChooseTrigger.RANGE_RECT then
      ChooseTrigger.chooseRoleByRect(usedDisInstance, rangeParams[0+1], rangeParams[1+1], rangeParams[2+1], rangeParams[3+1], targetArr, -1, out, nil, soucePos)
    elseif rangeType == ChooseTrigger.RANGE_FULLSCREEN then
      if targetArr then
        local i = 0
        repeat
          table.insert(out, targetArr[i+1])
          i=i+1
        until not(i < #targetArr)
      end
    else
      local i = 0
      repeat
        table.insert(out, targetArr[i+1])
        i=i+1
      until not(i < #targetArr)
    end
  else
    local i = 0
    repeat
      table.insert(out, targetArr[i+1])
      i=i+1
    until not(i < #targetArr)
  end
  ChooseTrigger.initArrpriority(out)
  ChooseTrigger.excludeUnChooseRole(instance, out)
  if #out > 0 then
    if targetData.targetType then
      ChooseTrigger.chooseByTargetType(out, targetData.targetType)
    end
    if targetData.targetChoose then
      local chooseCondArr = targetData.targetChoose
      local i = 0
      repeat
        -- [ts2lua]ChooseTrigger下标访问可能不正确
        local func = ChooseTrigger["chooseRoleBy_" .. chooseCondArr[i+1]]
        if not func then
          LogsManager.errorTag("cfgerror", "battle 没有对应的选择类型,targetId:", targetData.id, "targetChoose:", i)
        else
          doJsCallFunc(func,ChooseTrigger, instance, out)
        end
        i=i+1
      until not(i < #chooseCondArr)
    end
    if outArea then
      ChooseTrigger.chooseRoleBy_7(instance, out)
    end
    if targetNumber > 0 and targetNumber < #out then
      -- [ts2lua]修改数组长度需要手动处理。
      out.length = targetNumber
    end
  end
  if tempArr then
    BattleFunc.cacheOneTempArr(tempArr)
  end
  return out
end

function ChooseTrigger.getAoeTargetRole(aoeData, attacker, targetInstance, out)
  ChooseTrigger.getSkillTargetRole(attacker, nil, aoeData.chooseTartgetCfg, out, targetInstance, aoeData._initTargtPos)
  return out
end

function ChooseTrigger.chooseByTargetType(useArr, targetType)
  local i = #useArr - 1
  repeat
    local role = useArr[i+1]
    role.tempSortValue = 100
    local s = 0
    repeat
      local tempInfo = targetType[s+1]
      if role.lifeType == tonumber(tempInfo[0+1]) then
        local tempPri = tonumber(tempInfo[1+1])
        if tempPri == -1 then
          table.spliceArray(useArr,i, 1)
        else
          role.tempSortValue = tempPri
        end
        break
      end
      s=s+1
    until not(s < #targetType)
    role.tempSortPriority = role.tempSortValue
    i=i-1
  until not(i >= 0)
  useArr:sort(ChooseTrigger.sortByTmepValueAdd)
  return useArr
end

function ChooseTrigger.chooseRoleByCircle(instance, r, x, z, targetArr, chooseNums, out, excludeArr, ang, soucePos)
  if excludeArr == nil then
    excludeArr=nil
  end
  if ang == nil then
    ang=0
  end
  if soucePos == nil then
    soucePos=nil
  end
  -- [ts2lua]修改数组长度需要手动处理。
  out.length = 0
  if not ang then
    ang = 360
  end
  local useSourcePos = false
  if not soucePos then
    soucePos = instance.pos
  else
    useSourcePos = true
  end
  x = soucePos.x + x * instance._viewWay
  z = z + soucePos.z
  local y = instance.pos.y
  if instance.initOffsetY then
    y = y - instance.initOffsetY
  end
  if chooseNums == -1 then
    chooseNums = 9999
  end
  local spdx = instance.speed.x
  local spdy = instance.speed.y
  local spdz = instance.speed.z
  if useSourcePos then
    spdx = 0
    spdz = 0
  end
  local radArea = nil
  local spdAbs = math.sqrt(spdx * spdx + spdy * spdy + spdz * spdz)
  local powr = r + spdAbs * r + spdAbs
  if ang < 360 then
    radArea = ang * BattleFunc.angletoRad / 2
  end
  local i = 0
  repeat
    repeat
      local targetInstance = targetArr[i+1]
      if excludeArr and excludeArr:find(targetInstance) ~= -1 then
        break
      end
      local disx = targetInstance.pos.x - x
      local disy = targetInstance.pos.y - y
      local disz = targetInstance.pos.z - z
      if disx * disx + disz * disz + disy * disy <= powr then
        if ang < 360 then
          local disAng = math.atan2(disz, disx)
          if math.abs(disAng) > radArea then
            break
          end
        end
        table.insert(out, targetInstance)
        if #out == chooseNums then
          break
        end
      end
    until true
    i=i+1
  until not(i < #targetArr)
  return out
end

function ChooseTrigger.chooseRoleByRect(instance, w, h, x, z, targetArr, chooseNums, out, excludeArr, soucePos)
  if excludeArr == nil then
    excludeArr=nil
  end
  if soucePos == nil then
    soucePos=nil
  end
  -- [ts2lua]修改数组长度需要手动处理。
  out.length = 0
  local useSourcePos = false
  if not soucePos then
    soucePos = instance.pos
  else
    useSourcePos = true
  end
  x = soucePos.x + x * instance._viewWay
  z = soucePos.z
  local y = instance.pos.y
  if instance.initOffsetY then
    y = y - instance.initOffsetY
  end
  if chooseNums == -1 then
    chooseNums = 9999
  end
  local halfw = w / 2
  local halfh = h / 2
  local spdx = instance.speed.x
  local spdy = instance.speed.y
  local spdz = instance.speed.z
  if useSourcePos then
    spdx = 0
    spdz = 0
  end
  local i = 0
  repeat
    repeat
      local targetInstance = targetArr[i+1]
      if excludeArr and excludeArr:find(targetInstance) ~= -1 then
        break
      end
      local disSpdx = math.abs(targetInstance.speed.x - spdx)
      local disSpdz = math.abs(targetInstance.speed.z - spdz)
      local disSpdy = math.abs(targetInstance.speed.y - spdy)
      local disx = math.abs(targetInstance.pos.x - x)
      local disz = math.abs(targetInstance.pos.z - z)
      local disy = math.abs(targetInstance.pos.y - y)
      if (disx <= halfw + disSpdx and disz <= halfh + disSpdz) and disy <= h + disSpdy then
        table.insert(out, targetInstance)
        if #out == chooseNums then
          break
        end
      end
    until true
    i=i+1
  until not(i < #targetArr)
  return out
end

function ChooseTrigger.getRoleByFormation(formation, campArr)
  local i = 0
  repeat
    local ins = campArr[i+1]
    if ins.formationId == formation then
      return ins
    end
    i=i+1
  until not(i < #campArr)
  return nil
end

function ChooseTrigger.getPlayerById(id, campArr)
  local i = 0
  repeat
    local ins = campArr[i+1]
    if ins.dataId == id and ins.lifeType == BattleConst.LIFE_PLAYER then
      return ins
    end
    i=i+1
  until not(i < #campArr)
  return nil
end

function ChooseTrigger.checkCanChoose(attacker, defer)
  local targetBit = defer.ctrlBuffBit
  if targetBit & BuffTrigger.safeByAllBuffBit then
    return false
  elseif targetBit & BuffTrigger.safeBuffBit and defer.camp ~= attacker.camp then
    return false
  end
  return true
end

function ChooseTrigger.excludeUnChooseRole(attacker, targetArr)
  if #targetArr == 0 then
    return
  end
  local len = #targetArr
  local i = len - 1
  repeat
    local targetRole = targetArr[i+1]
    if not ChooseTrigger.checkCanChoose(attacker, targetRole) then
      table.spliceArray(targetArr,i, 1)
    end
    i=i-1
  until not(i >= 0)
end

function ChooseTrigger.chooseRoleBy_1(attacker, useArr, chooseNums)
  if chooseNums == nil then
    chooseNums=-1
  end
  return useArr
end

function ChooseTrigger.chooseRoleBy_2(attacker, useArr)
  local i = 0
  repeat
    local instance = useArr[i+1]
    instance.tempSortValue = RandomUtis.getUintRandom(BattleFunc.battleRandomIndex)
    i=i+1
  until not(i < #useArr)
  useArr:sort(ChooseTrigger.sortByTmepValueAdd)
  return useArr
end

function ChooseTrigger.chooseRoleBy_3(attacker, useArr)
  useArr:sort(ChooseTrigger.sortByHpAdd)
  return useArr
end

function ChooseTrigger.chooseRoleBy_4(attacker, useArr)
  useArr:sort(ChooseTrigger.sortByHpReduce)
  return useArr
end

function ChooseTrigger.chooseRoleBy_5(attacker, useArr)
  ChooseTrigger.comparePos = attacker.pos
  useArr:sort(ChooseTrigger.sortByFrontFormation)
  return useArr
end

function ChooseTrigger.initArrpriority(useArr)
  local i = 0
  repeat
    useArr[i+1].tempSortPriority = 100
    i=i+1
  until not(i < #useArr)
end

function ChooseTrigger.chooseRoleBy_6(attacker, useArr)
  ChooseTrigger.comparePos = attacker.pos
  useArr:sort(ChooseTrigger.sortByBackFormation)
  return useArr
end

function ChooseTrigger.chooseRoleBy_7(attacker, useArr)
  local minDisPower = nil
  local i = 0
  repeat
    local role2 = useArr[i+1]
    local dx = role2.pos.x - attacker.pos.x
    local dz = role2.pos.z - attacker.pos.z
    role2.tempSortValue = dx * dx + dz * dz
    i=i+1
  until not(i < #useArr)
  useArr:sort(ChooseTrigger.sortByTmepValueAdd)
  return useArr
end

function ChooseTrigger.chooseRoleBy_8(attacker, useArr)
  local i = 0
  repeat
    local role2 = useArr[i+1]
    local dx = role2.pos.x - attacker.pos.x
    local dz = role2.pos.z - attacker.pos.z
    role2.tempSortValue = dx * dx + dz * dz
    i=i+1
  until not(i < #useArr)
  useArr:sort(ChooseTrigger.sortByTmepValueReduce)
  return useArr
end

function ChooseTrigger.chooseRoleBy_9(attacker, useArr)
  local i = #useArr - 1
  repeat
    local instance = useArr[i+1]
    if instance.hp > 0 then
      instance.tempSortPriority = instance.tempSortPriority + 1
    end
    i=i-1
  until not(i >= 0)
  useArr:sort(ChooseTrigger.sortByPriority)
  return useArr
end

function ChooseTrigger.chooseRoleBy_10(attacker, useArr)
  useArr:sort(ChooseTrigger.sortByHpReducePercent)
  return useArr
end

function ChooseTrigger.chooseRoleBy_11(attacker, useArr)
  useArr:sort(ChooseTrigger.sortByHpAddPercent)
  return useArr
end

function ChooseTrigger.getTargetRoleByBuff(def, buffData, outArr)
  ChooseTrigger.getSkillTargetRole(def, nil, buffData.chooseTartgetCfg, outArr)
  return outArr
end

function ChooseTrigger.sortByPriority(r1, r2)
  return r1.tempSortPriority - r2.tempSortPriority
end

function ChooseTrigger.sortByHpAdd(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    if r1.hp > r2.hp then
      return 1
    elseif r1.hp == r2.hp then
      return 0
    else
      return -1
    end
  end
  return disPri
end

function ChooseTrigger.sortByHpReduce(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    if r1.hp > r2.hp then
      return -1
    elseif r1.hp == r2.hp then
      return 0
    else
      return 1
    end
  end
  return disPri
end

function ChooseTrigger.sortByHpReducePercent(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    if r1.hpPercent > r2.hpPercent then
      return -1
    elseif r1.hpPercent == r2.hpPercent then
      return 0
    else
      return 1
    end
  end
  return disPri
end

function ChooseTrigger.sortByHpAddPercent(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    if r1.hpPercent > r2.hpPercent then
      return 1
    elseif r1.hpPercent == r2.hpPercent then
      return 0
    else
      return -1
    end
  end
  return disPri
end

function ChooseTrigger.sortByFrontFormation(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    local disPos = r1.posType - r2.posType
    if disPos == 0 then
      local dis1 = ChooseTrigger.getPowerDis(r1.pos, ChooseTrigger.comparePos)
      local dis2 = ChooseTrigger.getPowerDis(r2.pos, ChooseTrigger.comparePos)
      return dis1 - dis2
    else
      return disPos
    end
  end
  return disPri
end

function ChooseTrigger.sortByBackFormation(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    local disPos = r2.posType - r1.posType
    if disPos == 0 then
      local dis1 = ChooseTrigger.getPowerDis(r1.pos, ChooseTrigger.comparePos)
      local dis2 = ChooseTrigger.getPowerDis(r2.pos, ChooseTrigger.comparePos)
      return dis1 - dis2
    else
      return disPos
    end
  end
  return disPri
end

function ChooseTrigger.sortByTmepValueAdd(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    return r1.tempSortValue - r2.tempSortValue
  end
  return disPri
end

function ChooseTrigger.sortByTmepValueReduce(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    return r2.tempSortValue - r1.tempSortValue
  end
  return disPri
end

function ChooseTrigger.sortByRandom(r1, r2)
  local disPri = r1.tempSortPriority - r2.tempSortPriority
  if disPri == 0 then
    local random = RandomUtis.getOneRandom(BattleFunc.battleRandomIndex)
    return random - 0.5
  end
  return disPri
end
