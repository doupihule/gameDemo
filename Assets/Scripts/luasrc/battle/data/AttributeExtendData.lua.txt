



AttributeExtendData = class('AttributeExtendData')

function AttributeExtendData:ctor(id, roleData, lifeType, userData, globalAttrMap, outRecount)
  self.level = 1;
  self.starLevel = 0;
  self.hasDataChange = false;
  self.hasCountPassive = false;
  self._hasTempAttrChange = false;
  if globalAttrMap == nil then
    globalAttrMap=nil
  end
  if outRecount == nil then
    outRecount=false
  end
  self:resetData(id, roleData, lifeType, userData, globalAttrMap)
end

function AttributeExtendData:resetData(id, roleData, lifeType, userData, globalAttrMap, outRecount)
  if globalAttrMap == nil then
    globalAttrMap=nil
  end
  if outRecount == nil then
    outRecount=false
  end
  self.id = id
  self.skillCdMap = {}
  self._data = roleData
  self._userData = userData
  self.extraAttr = {}
  self.tempOnceAttr = {}
  self.baseAttr = {}
  self.addAttr = {}
  self.finalAttr = {}
  self.hasCountPassive = false
  self.lifeType = lifeType
  self:updateData(roleData, globalAttrMap, outRecount)
end

function AttributeExtendData:updateData(roleData, globalAttrMap, outRecount)
  if globalAttrMap == nil then
    globalAttrMap=nil
  end
  if outRecount == nil then
    outRecount=false
  end
  self._globalAttrMap = globalAttrMap
  local attrId = nil
  local advanceAttr = nil
  self.level = roleData.level or 1
  self.starLevel = roleData.starLevel or 0
  self.equip = roleData.equip or nil
  local attrArr = BattleFunc.instance:getCfgDatasByMultyKey("RoleUpdate", self.id, self.level, "attribute")
  self.baseAttr = self:resetBaseAtt(attrArr)
  self:countPassiveAttr(roleData)
  if not outRecount then
    self:countAllAttr()
  end
end

function AttributeExtendData:countSummonedAttr(level, fromAttr)
  local attrArr = BattleFunc.instance:getCfgDatasByMultyKey("RoleUpdate", self.id, level, "attribute")
  self.baseAttr = self:resetBaseAtt(attrArr)
  self:countAllAttr()
end

function AttributeExtendData:resetBaseAtt(attrArr)
  attrArr = BattleFunc.instance:turnPropArrToTable(attrArr)
  if self.lifeType ~= BattleConst.LIFE_JIDI then
    for key in pairs(attrArr) do
      if attrArr:hasOwnProperty(key) then
        -- [ts2lua]attrArr下标访问可能不正确
        local info = attrArr[key]
        info[0+1] = RolesFunc.instance:getAttrNumByLevel(key, self.id, self.level, self.starLevel, true, nil, self.equip)
        -- [ts2lua]attrArr下标访问可能不正确
        attrArr[key] = info
      end
    end
  end
  return attrArr
end

function AttributeExtendData:countPassiveAttr(roleData)
  if self.lifeType == BattleConst.LIFE_PLAYER then
    return
  end
  if self.hasCountPassive then
    return
  end
  local passSkill = roleData.passiveSkills
  if not passSkill or #passSkill == 0 then
    return
  end
  self.hasCountPassive = true
  local i = 0
  repeat
    local passiveId = passSkill[i+1]
    local passiveCfg = BattleFunc.instance:getCfgDatas("PassiveSkill", passiveId)
    local effectType = passiveCfg.effectType
    local tempArr = {}
    if effectType == BattleConst.passive_effect_attr then
      local effectParams = passiveCfg.effectParams
      local s = 0
      repeat
        tempArr = effectParams[s+1]
        self:updateOneAttr(tempArr[0+1], Number(tempArr[1+1]), Number(tempArr[2+1]), self.extraAttr, true)
        s=s+1
      until not(s < #effectParams)
    elseif effectType == BattleConst.passive_effect_skillcd then
      local effectParams = passiveCfg.effectParams
      local s = 0
      repeat
        local arr = effectParams[s+1]
        local skillId = tostring(arr[0+1])
        local value = Number(arr[1+1])
        local skillValue = 10000 + value
        if skillValue < 0 then
          skillValue = 0
        end
        -- [ts2lua]self.skillCdMap下标访问可能不正确
        self.skillCdMap[skillId] = skillValue
        s=s+1
      until not(s < #effectParams)
    end
    i=i+1
  until not(i < #passSkill)
end

function AttributeExtendData:countAllAttr()
  for i in pairs(BattleFunc.idToShowMap) do
    self:countOneProp(i)
  end
  self.hasDataChange = false
end

function AttributeExtendData:clearTempAttr()
  if not self._hasTempAttrChange then
    return
  end
  self._hasTempAttrChange = false
  local map = self.tempOnceAttr
  for i in pairs(map) do
    local tempArr = map[i+1]
    if tempArr[0+1] ~= 0 or tempArr[1+1] ~= 0 then
      map[i+1][0+1] = 0
      map[i+1][1+1] = 0
      self:countOneProp(i)
    end
  end
end

function AttributeExtendData:countOneProp(attrId)
  local showType = BattleFunc.getPropStyle(attrId)
  -- [ts2lua]self.baseAttr下标访问可能不正确
  -- [ts2lua]self.baseAttr下标访问可能不正确
  local baseValue = self.baseAttr[attrId] and self.baseAttr[attrId][0+1] or 0
  -- [ts2lua]self.extraAttr下标访问可能不正确
  -- [ts2lua]self.extraAttr下标访问可能不正确
  local fixValue = self.extraAttr[attrId] and self.extraAttr[attrId][0+1] or 0
  -- [ts2lua]self.extraAttr下标访问可能不正确
  -- [ts2lua]self.extraAttr下标访问可能不正确
  local percentValue = self.extraAttr[attrId] and self.extraAttr[attrId][1+1] or 0
  -- [ts2lua]self.tempOnceAttr下标访问可能不正确
  -- [ts2lua]self.tempOnceAttr下标访问可能不正确
  fixValue = fixValue + self.tempOnceAttr[attrId] and self.tempOnceAttr[attrId][0+1] or 0
  -- [ts2lua]self.tempOnceAttr下标访问可能不正确
  -- [ts2lua]self.tempOnceAttr下标访问可能不正确
  percentValue = percentValue + self.tempOnceAttr[attrId] and self.tempOnceAttr[attrId][1+1] or 0
  local resultValue = nil
  if showType == BattleConst.PROPSTYLE_NUM then
    resultValue = 1 + percentValue / 10000 * baseValue + fixValue
  else
    resultValue = baseValue + fixValue
  end
  resultValue = math.floor(resultValue)
  -- [ts2lua]self.finalAttr下标访问可能不正确
  self.finalAttr[attrId] = resultValue
end

function AttributeExtendData:changeExtraAttr(srcMap, way, recountAttr)
  if way == nil then
    way=1
  end
  if recountAttr == nil then
    recountAttr=false
  end
  local targetMap = self.extraAttr
  for i in pairs(srcMap) do
    if not targetMap[i+1] then
      targetMap[i+1] = {0, 0}
    end
    targetMap[i+1][0+1] = targetMap[i+1][0+1] + srcMap[i+1][0+1] * way
    targetMap[i+1][1+1] = targetMap[i+1][1+1] + srcMap[i+1][1+1] * way
    if recountAttr then
      self:countOneProp(i)
    end
  end
end

function AttributeExtendData:changeTempAttr(srcMap)
  local targetMap = self.tempOnceAttr
  for i in pairs(srcMap) do
    self:changeOneTempAttr(i, srcMap[i+1][0+1], srcMap[i+1][1+1])
  end
end

function AttributeExtendData:changeOneTempAttr(attrId, fixValue, percentValue)
  self._hasTempAttrChange = true
  self:updateOneAttr(attrId, fixValue, percentValue, self.tempOnceAttr)
end

function AttributeExtendData:updateOneAttr(attrId, fixValue, percentValue, changeMap, outRecount)
  if outRecount == nil then
    outRecount=false
  end
  -- [ts2lua]changeMap下标访问可能不正确
  local arr = changeMap[attrId]
  if not arr then
    arr = {0, 0}
    -- [ts2lua]changeMap下标访问可能不正确
    changeMap[attrId] = arr
  end
  arr[0+1] = arr[0+1] + fixValue
  arr[1+1] = arr[1+1] + percentValue
  if not outRecount then
    self:countOneProp(attrId)
  end
end

function AttributeExtendData:getSkillCdAdded(skillId)
  -- [ts2lua]self.skillCdMap下标访问可能不正确
  return self.skillCdMap[skillId] or 10000
end

function AttributeExtendData:getOneAttr(propId)
  -- [ts2lua]self.finalAttr下标访问可能不正确
  return self.finalAttr[propId] or 0
end
