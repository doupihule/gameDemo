BattleControler = class('BattleControler')
function BattleControler:ctor(ctn)
  self._isGamePause = false;
  self.isSkillPause = false;
  self._leftFrameDt = 0;
  self.callFuncNums = 0;
  self.updateCount = 0;
  self._lastFrameTime = 0;
  self.stillFrame = 0;
  self.updateScale = 1;
  self._leftScaleFrame = 0;
  self._leftCatchTime = 0;
  self.performanceControler = PerformanceControler.new(self)
  self._allInstanceArr = {}
  self.battleState = BattleConst.battleState_out
  self.cameraControler = CameraControler.new(self)
  self._timeList = {}
  self._cacheTimeArr = {}
  self.updateCallFuncGroup = {}
  
  self._oneFrameDt = math.round(1000 / GameConsts.gameFrameRate)
  self._maxFrameDt = 5 * self._oneFrameDt
  self.tweenControler = BattleTweenControler.new(self)
  self.battleDebugTool = BattleDebugTool.new(self)
  self.updateScale = BattleDebugTool.getBattleAddSped()
  if not self.updateScale then
    self.updateScale = 1
  end
end

function BattleControler:onceUpdateFrame()
  local currentT = cs.GameUtils.CommonUtil.GetTimeMiniStamp()
  local dt = currentT - self._lastFrameTime
  if dt > self._maxFrameDt then
    dt = self._maxFrameDt
  end
  self._lastFrameTime = currentT
  self._leftFrameDt = self._leftFrameDt + dt
  local nums = math.floor(self._leftFrameDt / self._oneFrameDt)
  self._leftFrameDt = self._leftFrameDt - nums * self._oneFrameDt
  local i = 0
  repeat
    if self.updateScale == 1 then
      self:updateFrame()
    else
      self._leftScaleFrame = self._leftScaleFrame + self.updateScale
      local s = 0
      s = 0
      repeat
        self:updateFrame()
        s=s+1
      until not(s < self._leftScaleFrame)
      self._leftScaleFrame = self._leftScaleFrame - s
    end
    i=i+1
  until not(i < nums)
end

function BattleControler:updateFrame()
  self.updateCount=self.updateCount+1
  self.refreshControler:updateFrame()
  self:runInstanceUpdate()
  self.cameraControler:updateFrame()
  self.tweenControler:updateFrame()
  self:doDelayCallFunc()
  for i in pairs(self.updateCallFuncGroup) do
    local info = self.updateCallFuncGroup[i]
    info.callBack:call(info.thisObj, info.params)
    if info.frame > 0 then
      info.frame=info.frame-1
      if info.frame == 0 then
        self.updateCallFuncGroup[i] = nil
      end
    end
  end
  self:sortChildren()
end


function BattleControler:sortChildren(isForce)
  if isForce == nil then
    isForce=false
  end
  if not isForce and self.updateCount % 60 ~= 0 then
    return
  end
  self:sortOneArr(self._allInstanceArr)
end

function BattleControler:sortOneArr(campArr)
  local i = 0
  for i,v in ipairs(campArr) do
    v:updateViewZorder()
  end
end

function BattleControler:doDelayCallFunc()
  if #self._timeList == 0 then
    return
  end
  local i
  if not self.isSkillPause then
    for i=#self._timeList,1,-1 do
      local info = self._timeList[i]
        if not info then
          BattleLogsManager.battleEcho("_在延迟回调里面做了清理延迟回调事情,导致序列变了")
          break
        end
        self:doOneCallInfo(info, i)
        local obj = info.thisObj
        if obj and obj.upTimeScale then
          info.frame = info.frame - obj.upTimeScale
        else
          info.frame = info.frame - 1
        end
    end
  else
    for i=#self._timeList,1,-1 do
      local info = self._timeList[i]
      if not info then
        BattleLogsManager.battleEcho("_在延迟回调里面做了清理延迟回调事情,导致序列变了")
        break
      end
      local thisObj = info.thisObj
      local isRunWithSkillPause = true
      if (thisObj and thisObj.isRunWithSkillPause) and not thisObj:isRunWithSkillPause() then
        isRunWithSkillPause = false
      end
      if isRunWithSkillPause then
        self:doOneCallInfo(info, i)
        if thisObj and thisObj.upTimeScale then
          info.frame = info.frame - thisObj.upTimeScale
        else
          info.frame = info.frame - 1
        end
      end
    end
  end
end

function BattleControler:doOneCallInfo(info, i)
  if i == nil then
    i=-1
  end
  if info.frame <= 0 then
    if info.times > 0 then
      info.times=info.times-1
    end
    local doApplyOrCall = info.doApplyOrCall
    local callBack = info.callBack
    local thisObj = info.thisObj
    local params = info.params
    local endCallBack = info.endCallBack
    local endParams = info.endParams
    if info.times == 0 then
      table.insert(self._cacheTimeArr, info)
      if i ~= -1 then
        self._timeList:splice(i, 1)
      end
      if endCallBack then
        if doApplyOrCall then
          endCallBack:apply(thisObj, endParams)
        else
          endCallBack:call(thisObj, endParams)
        end
      end
    else
      info.frame = info.interval
    end
    if callBack then
      if doApplyOrCall then
        callBack:apply(thisObj, params)
      else
        callBack:call(thisObj, params)
      end
    end
  end
end

function BattleControler:getOneCacheTimeObj()
  if #self._cacheTimeArr == 0 then
    return {}
  else
    return self._cacheTimeArr:shift()
  end
end

function BattleControler:runInstanceUpdate()
  if self.player then
    self.player:updateFrame()
  end
  local len = #self._allInstanceArr
  local i = len - 1
  repeat
    local instance = self._allInstanceArr[i+1]
    if instance and instance:checkIsUsing() then
      if not self.isSkillPause or instance:isRunWithSkillPause() then
        instance:updateFrame()
      end
    end
    i=i-1
  until not(i >= 0)
  self:checkHit()
  local i = len - 1
  repeat
    local instance = self._allInstanceArr[i+1]
    if instance and instance:checkIsUsing() then
      if not self.isSkillPause or instance:isRunWithSkillPause() then
        instance:updateFrameLater()
      end
    end
    i=i-1
  until not(i >= 0)
end

function BattleControler:checkHit() end
function BattleControler:setCallBack(frame, callBack, thisObj, params, doApplyOrCall)
  if params == nil then
    params=nil
  end
  if doApplyOrCall == nil then
    doApplyOrCall=false
  end
  if frame == nil or isNaN(frame) then
    LogsManager.errorTag("battleerror", "没有传入frame,直接做回调")
  end
  local obj = self:getOneCacheTimeObj()
  if not frame then
    if doApplyOrCall then
      callBack:apply(thisObj, params)
    else
      callBack:call(thisObj, params)
    end
    return
  end
  obj.frame = frame
  obj.interval = frame
  obj.times = 1
  obj.callBack = callBack
  obj.thisObj = thisObj
  obj.params = params
  obj.doApplyOrCall = doApplyOrCall
  table.insert(self._timeList, obj)
end

function BattleControler:setLastCallBack(delay, interval, times, callBack, thisObj, params, endCallBack, endParams, doApplyOrCall)
  if params == nil then
    params=nil
  end
  if endCallBack == nil then
    endCallBack=nil
  end
  if endParams == nil then
    endParams=nil
  end
  if doApplyOrCall == nil then
    doApplyOrCall=false
  end
  if delay == nil or isNaN(delay) then
    LogsManager.errorTag("battleerror", "没有传入frame")
    return
  end
  local obj = self:getOneCacheTimeObj()
  obj.frame = delay
  obj.interval = interval
  obj.times = times
  obj.callBack = callBack
  obj.thisObj = thisObj
  obj.params = params
  obj.doApplyOrCall = doApplyOrCall
  obj.endCallBack = endCallBack
  obj.endParams = endParams
  table.insert(self._timeList, obj)
  self:doOneCallInfo(obj, #self._timeList - 1)
end

function BattleControler:clearCallBack(thisObj, callBack, params)
  if callBack == nil then
    callBack=nil
  end
  if params == nil then
    params=nil
  end
  local i = #self._timeList - 1
  repeat
    local obj = self._timeList[i+1]
    if thisObj == obj.thisObj then
      if not callBack then
        self._timeList:splice(i, 1)
      else
        if callBack == obj.callBack then
          if params == nil then
            self._timeList:splice(i, 1)
          else
            if params == obj.params then
              self._timeList:splice(i, 1)
            end
          end
        end
      end
    end
    i=i-1
  until not(i >= 0)
end

function BattleControler:registObjUpdate(callFunc, callThisObj, params, frame)
  if params == nil then
    params=nil
  end
  if frame == nil then
    frame=-1
  end
  self.callFuncNums=self.callFuncNums+1
  -- [ts2lua]self.updateCallFuncGroup下标访问可能不正确
  self.updateCallFuncGroup[tostring(self.callFuncNums)] = {callBack=callFunc, thisObj=callThisObj, params=params, frame=frame}
  return self.callFuncNums
end

function BattleControler:deleteObjUpdate(callFuncNums, callFunc, callThisObj)
  if callFuncNums == nil then
    callFuncNums=nil
  end
  local index = 0
  repeat
    if callFuncNums == index then
      -- [ts2lua]self.updateCallFuncGroup下标访问可能不正确
      self.updateCallFuncGroup[index] = nil
      break
    end
    index=index+1
  until not(index < #self.updateCallFuncGroup)
end

function BattleControler:insterInstanceToArr(instance)
  if self._allInstanceArr:find(instance) == -1 then
    table.insert(self._allInstanceArr, instance)
  end
end

function BattleControler:getAllInstanceArr()
  return self._allInstanceArr
end

function BattleControler:setBattleState(value)
  self.battleState = value
end

function BattleControler:setGamePlayOrPause(value)
  self._isGamePause = value
end

function BattleControler:dispose()
  if self._isDisposed then
    return
  end
  self._timeList = {}
end
