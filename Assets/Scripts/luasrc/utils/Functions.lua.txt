--
-- Author: xd
-- Date: 2014-03-14 10:34:57
--


-- newindexFunc()
-- override the normal Lua lookup functionality to allow
-- property setter functions
--
-- @param t object table
-- @param k key
-- @param v value
--
local function newindexFunc( t, k, v )

	local o, f

	-- check for key in setters table
	o = rawget( t, '__setters' ) or {}
	f = o[k]
	if f then
		-- found setter, so call it
		f(t,v)
	else
		-- place key/value directly on object
		rawset( t, k, v )
	end

end


-- multiindexFunc()
-- override the normal Lua lookup functionality to allow
-- property getter functions
--
-- @param t object table
-- @param k key
--
local function multiindexFunc( t, k )

	local o, val

	--== do key lookup in different places on object

	-- check for key in getters table
	o = rawget( t, '__getters' ) or {}
	if o[k] then return o[k](t) end

	-- check for key directly on object
	val = rawget( t, k )
	if val ~= nil then return val end

	-- check OO hierarchy
	-- check Parent Lock else all of Parents
	--
	o = rawget( t, '__parent_lock' )
	if o then
		if o then val = o[k] end
		if val ~= nil then return val end
	else
		local par = rawget( t, '__parents' )
		for _, o in ipairs( par ) do
			if o[k] ~= nil then
				val = o[k]
				break
			end
		end
		if val ~= nil then return val end
	end

	return nil
end


-- blessObject()
-- create new object, setup with Lua OO aspects, dmc-style aspects
-- @params inheritance table of supers/parents (dmc-style objects)
-- @params params
-- params.object
-- params.set_isClass
--
local function blessObject( inheritance, params )
	params = params or {}
	params.object = params.object or {}
	params.set_isClass = params.set_isClass == true and true or false
	--==--
	local o = params.object
	local o_id = tostring(o)
	local mt = {
		__index = multiindexFunc,
		__newindex = newindexFunc,
	}
	setmetatable( o, mt )

	-- add Class property, access via getters:supers()
	o.__parents = inheritance
	o.__is_dmc = true

	-- create lookup tables - setters, getters
	o.__setters = {}
	o.__getters = {}

	-- copy down all getters/setters of parents
	-- do in reverse order, to match order of property lookup
	local cls = inheritance
	if cls.__getters then
		o.__getters = Utils.extend( cls.__getters, o.__getters )
	end
	if cls.__setters then
		o.__setters = Utils.extend( cls.__setters, o.__setters )
	end

	return o
end



--定义clas
function class(classname, super)
    local superType = type(super)
    local cls

    if superType ~= "function" and superType ~= "table" then
        superType = nil
        super = nil
    end
    -- inherited from Lua Object
    if super then
        -- setmetatable(cls, {__index = super})
        
        cls =blessObject(super,{})
        cls.super = super
    else
        cls = blessObject({ctor = function() end},{} )
    end

    cls.__cname = classname
    cls.__ctype = 2 -- lua
    cls.__index = cls

    function cls.new(...)
        local instance = setmetatable({}, cls)
        instance.class = cls
        instance:ctor(...)
        return instance
    end

    return cls
end

--[[--

如果对象是指定类或其子类的实例，返回 true，否则返回 false

~~~ lua

local Animal = class("Animal")
local Duck = class("Duck", Animal)

print(iskindof(Duck.new(), "Animal")) -- 输出 true

~~~

@param mixed obj 要检查的对象
@param string classname 类名

@return boolean

]]




--定义一些静态的数据
math.cospi4 = math.cos( math.pi/4 )


local oldAtan2 = math.atan2

math.atan2=function ( dy,dx )
	if dy ==0 and dx ==0 then
		return 0
	end
	return oldAtan2(dy,dx)
end






-- return var or def
function vcheck(var,def)
	if var==nil then return def end
	return var
end

--一个对象是否为空 
function empty(var)
	return not var or var=="" or var==0 or (type(var)=="table" and table.isEmpty(var))
end



function tonum(v, base)
    return tonumber(v, base) or 0
end

function toint(v)
    return math.round(tonumber(v))
end

function tobool(v)
    return (v ~= nil and v ~= false)
end





--[[
-- 简单的函数传递，用于各种事件时传递函数，可传递任意多个参数
-- 格式: c_func(func,a,b,c)
-- Usage:
	[1]基本使用方法
	有一个方法，需要传递函数
	function AAA:registerFunc(aaa_func) aaa_func() end
	若需要传递的函数为
	local function func(...) echo(...) end
	使用时
	self:registerFunc(func) --正常无法传递参数
	self:registerFunc(c_func(func,1)) --传递1个参数 --aaa_func被调用时打印输出为 1
	self:registerFunc(c_func(func,1,"a",{})) --传递3个参数 --aaa_func被调用时打印输出为 1 "a" table
	[2]另外，某些冒号函数的事件传递方法
	function AAA:bbb_func(...) echo(...) end
	self:registerFunc(c_func(self.bbb_func,self,1,"a")) --bbb_func被调用时打印输出为 1 "a"
	[3]另外支持，在调用时可以附加更多的参数值进来，如
	function AAA:registerFunc(ccc_func) ccc_func(4,5,6) end --参数值456是作为额外参数传递给ccc_func
	local function func(...) echo(...) end
	self:registerFunc(c_func(func,self,1,"a")) --ccc_func被调用时打印输出为 1 "a" 4 5 6 (会同时得到调用时传入的456)
 ]]
function c_func(f,...)
	local _args = {...}
	if not f then
		error("传递了空函数")
		dump(_args,"____args")
	end

	local maxNums = 0
	for k,v in pairs(_args) do
		maxNums = math.max(k,maxNums)
	end

	for i=1,maxNums do
		if not _args[i] then
			_args[i] = false
		end
	end

	return function(...)
		local _tmp = table.copy(_args)
		table.array_merge(_tmp,{...})
		return f(unpack(_tmp))
	end
end






--矩形工具
rectEx= rectEx or {}
--是否包含一个点rect格式 x,y,w,h r = {x= x,y=y,w =w,h = h},    border 检测边界
function rectEx.contain(r,x,y ,border)
	border = border  and border or 0
	r.w = r.w or r.width
	r.h = r.h or r.height
	if x <r.x - border or x >r.x+r.w + border or y < r.y -border or y > r.y + r.h +border then
		return false
	end
	return true

end

function rectEx.mergeRect(rect1,rect2)
	-- rect1宽高为0，直接返回rect2
	if not rect1 or rect1.width<=0 or rect1.height<=0 then
		return rect2
	end
	-- rect2宽高为0，直接返回rect1
	if not rect2 or rect2.width<=0 or rect2.height<=0 then
		return rect1
	end
	-- 都有宽高，合并之
	local _minx = math.min(rect1.x,rect2.x)
	local _maxx = math.max(rect1.x+rect1.width,rect2.x + rect2.width)
	local _miny = math.min(rect1.y,rect2.y)
	local _maxy = math.max(rect1.y + rect1.height,rect2.y + rect2.height)
	return cc.rect(_minx,_miny,_maxx-_minx, _maxy-_miny)
end

--圆
circleEx= circleEx or {}
--判断一个点是否在圆内 圆的格式 {x=,y=,r=},border 检测留多少边界
function circleEx.contain(c,x,y,border )
	border = border  or 0
	local r = number.numBorder(c.r - border,0)
	local dx = x-c.x
	local dy = y -c.y
	if dx*dx+dy*dy>r*r then
	 	return false
	end 
	return true
end


--点工具
pointEx = pointEx or {}

--跟点赋予 transFrom 形变
function pointEx.pointApplyTransform(point,t )
	local p = {}
	p.x = t.a * point.x + t.c * point.y + t.tx;
	p.y = t.b * point.x + t.d * point.y + t.ty;
	return p
end


--给矩阵赋予 transFrom matrix 形变
--transfrom ,a,b,c,d,tx, ty
function rectEx.rectApplyTransform(rect,transfrom )



	local top = rect.y + rect.height
	local left = rect.x
	local right =rect.x + rect.width
	local bottom =rect.y

	local topLeft =pointEx.pointApplyTransform(cc.p(left,top),transfrom)
	local topRight =pointEx.pointApplyTransform(cc.p(right, top),transfrom)
	local bottomLeft =pointEx.pointApplyTransform(cc.p(left, bottom),transfrom)
	local bottomRight =pointEx.pointApplyTransform(cc.p(right, bottom),transfrom)


	--存储max min函数
	local min = math.min
	local max = math.max

	local minX = min(min(topLeft.x, topRight.x), min(bottomLeft.x, bottomRight.x));
    local maxX = max(max(topLeft.x, topRight.x), max(bottomLeft.x, bottomRight.x));
    local minY = min(min(topLeft.y, topRight.y), min(bottomLeft.y, bottomRight.y));
    local maxY = max(max(topLeft.y, topRight.y), max(bottomLeft.y, bottomRight.y));

    local result = cc.rect(minX,minY,(maxX-minX),(maxY- minY))
    return result

end


-- dump(rectEx.rectApplyTransform(cc.rect(0,0,960,54) ,{a=0.7070770263671875, b=-0.7070770263671875, c=-0.70709228515625, d=-0.70709228515625, tx=-0.3, ty=-1.3}   ) 		)



--以后还会有更多扩展  比如矩形是否与矩形相交  矩形是否和圆相交==








