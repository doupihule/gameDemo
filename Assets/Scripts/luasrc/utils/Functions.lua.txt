--
-- Author: xd
-- Date: 2014-03-14 10:34:57
--


-- newindexFunc()
-- override the normal Lua lookup functionality to allow
-- property setter functions
--
-- @param t object table
-- @param k key
-- @param v value
--
local function newindexFunc( t, k, v )

	local o, f

	-- check for key in setters table
	o = rawget( t, '__setters' ) or {}
	f = o[k]
	if f then
		-- found setter, so call it
		f(t,v)
	else
		-- place key/value directly on object
		rawset( t, k, v )
	end

end


-- multiindexFunc()
-- override the normal Lua lookup functionality to allow
-- property getter functions
--
-- @param t object table
-- @param k key
--
local function multiindexFunc( t, k )

	local o, val

	--== do key lookup in different places on object

	-- check for key in getters table
	o = rawget( t, '__getters' ) or {}
	if o[k] then return o[k](t) end

	-- check for key directly on object
	val = rawget( t, k )
	if val ~= nil then return val end

	-- check OO hierarchy
	-- check Parent Lock else all of Parents
	--
	o = rawget( t, '__parent_lock' )
	if o then
		if o then val = o[k] end
		if val ~= nil then return val end
	else
		local par = rawget( t, '__parents' )
		for _, o in ipairs( par ) do
			if o[k] ~= nil then
				val = o[k]
				break
			end
		end
		if val ~= nil then return val end
	end

	return nil
end


-- blessObject()
-- create new object, setup with Lua OO aspects, dmc-style aspects
-- @params inheritance table of supers/parents (dmc-style objects)
-- @params params
-- params.object
-- params.set_isClass
--
local function blessObject( inheritance, params )
	params = params or {}
	params.object = params.object or {}
	params.set_isClass = params.set_isClass == true and true or false
	--==--
	local o = params.object
	local o_id = tostring(o)
	local mt = {
		__index = multiindexFunc,
		__newindex = newindexFunc,
	}
	setmetatable( o, mt )

	-- add Class property, access via getters:supers()
	o.__parents = inheritance
	o.__is_dmc = true

	-- create lookup tables - setters, getters
	o.__setters = {}
	o.__getters = {}

	-- copy down all getters/setters of parents
	-- do in reverse order, to match order of property lookup
	local cls = inheritance
	if cls.__getters then
		o.__getters = Utils.extend( cls.__getters, o.__getters )
	end
	if cls.__setters then
		o.__setters = Utils.extend( cls.__setters, o.__setters )
	end

	return o
end



--定义clas
function class(classname, super)
    local superType = type(super)
    local cls

    if superType ~= "function" and superType ~= "table" then
        superType = nil
        super = nil
    end
    -- inherited from Lua Object
    if super then
        -- setmetatable(cls, {__index = super})
        
        cls =blessObject(super,{})
        cls.super = super
    else
        cls = blessObject({ctor = function() end},{} )
    end

    cls.__cname = classname
    cls.__ctype = 2 -- lua
    cls.__index = cls

    function cls.new(...)
        local instance = setmetatable({}, cls)
        instance.class = cls
        instance:ctor(...)
        return instance
    end

    return cls
end

--[[--

如果对象是指定类或其子类的实例，返回 true，否则返回 false

~~~ lua

local Animal = class("Animal")
local Duck = class("Duck", Animal)

print(iskindof(Duck.new(), "Animal")) -- 输出 true

~~~

@param mixed obj 要检查的对象
@param string classname 类名

@return boolean

]]




--定义一些静态的数据
math.cospi4 = math.cos( math.pi/4 )


local oldAtan2 = math.atan2

math.atan2=function ( dy,dx )
	if dy ==0 and dx ==0 then
		return 0
	end
	return oldAtan2(dy,dx)
end






-- return var or def
function vcheck(var,def)
	if var==nil then return def end
	return var
end

--一个对象是否为空 
function empty(var)
	return not var or var=="" or var==0 or (type(var)=="table" and table.isEmpty(var))
end



function tonum(v, base)
    return tonumber(v, base) or 0
end

function toint(v)
    return math.round(tonumber(v))
end

function tobool(v)
    return (v ~= nil and v ~= false)
end





--[[
-- 简单的函数传递，用于各种事件时传递函数，可传递任意多个参数
-- 格式: c_func(func,a,b,c)
-- Usage:
	[1]基本使用方法
	有一个方法，需要传递函数
	function AAA:registerFunc(aaa_func) aaa_func() end
	若需要传递的函数为
	local function func(...) echo(...) end
	使用时
	self:registerFunc(func) --正常无法传递参数
	self:registerFunc(c_func(func,1)) --传递1个参数 --aaa_func被调用时打印输出为 1
	self:registerFunc(c_func(func,1,"a",{})) --传递3个参数 --aaa_func被调用时打印输出为 1 "a" table
	[2]另外，某些冒号函数的事件传递方法
	function AAA:bbb_func(...) echo(...) end
	self:registerFunc(c_func(self.bbb_func,self,1,"a")) --bbb_func被调用时打印输出为 1 "a"
	[3]另外支持，在调用时可以附加更多的参数值进来，如
	function AAA:registerFunc(ccc_func) ccc_func(4,5,6) end --参数值456是作为额外参数传递给ccc_func
	local function func(...) echo(...) end
	self:registerFunc(c_func(func,self,1,"a")) --ccc_func被调用时打印输出为 1 "a" 4 5 6 (会同时得到调用时传入的456)
 ]]
function c_func(f,...)
	local _args = {...}
	if not f then
		error("传递了空函数")
		dump(_args,"____args")
	end

	local maxNums = 0
	for k,v in pairs(_args) do
		maxNums = math.max(k,maxNums)
	end

	for i=1,maxNums do
		if not _args[i] then
			_args[i] = false
		end
	end

	return function(...)
		local _tmp = table.copy(_args)
		table.array_merge(_tmp,{...})
		return f(unpack(_tmp))
	end
end



--执行类似js的回调
function doJsCallFunc( callFunc,thisObj,params )
	if not callFunc then 
		return
	end
	if( thisObj) then
		callFunc(thisObj,params)
	else
		callFunc(params)
	end
end

--执行类似js allpy的回调
function doJsApplyFunc( callFunc,thisObj,paramsArr )
	if not callFunc then 
		return
	end
	if( thisObj) then
		callFunc(thisObj,unpack(paramsArr))
	else
		callFunc(unpack(paramsArr))
	end
end



--以后还会有更多扩展  比如矩形是否与矩形相交  矩形是否和圆相交==








