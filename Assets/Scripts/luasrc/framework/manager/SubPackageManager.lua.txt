require("framework/common/UserInfo")
require("framework/manager/LogsManager")
require("game/sys/consts/SubPackageConst")
require("framework/utils/FileUtils")

SubPackageManager = class('SubPackageManager')
SubPackageManager.subPackLoadData = {};
SubPackageManager.canSubpack = true;
SubPackageManager._hasInitGroup = false;
function SubPackageManager._initGroupSubpack()
  if SubPackageManager._hasInitGroup then
    return
  end
  SubPackageManager._hasInitGroup = true
  -- [ts2lua]SubPackageConst下标访问可能不正确
  SubPackageManager._initOneGroup(SubPackageConst["spineGroupCfgs"])
  -- [ts2lua]SubPackageConst下标访问可能不正确
  SubPackageManager._initOneGroup(SubPackageConst["soundGroupCfgs"])
  -- [ts2lua]SubPackageConst下标访问可能不正确
  SubPackageManager._initOneGroup(SubPackageConst["model3dGroupCfgs"])
end

function SubPackageManager._initOneGroup(arr)
  if not arr then
    return
  end
  local i = 0
  repeat
    local groupInfo = arr[i+1]
    local packName = groupInfo.name
    local path = groupInfo.path
    SubPackageManager.insertDynamicSubPack(packName, path)
    i=i+1
  until not(i < #arr)
end

function SubPackageManager.loadSubPackage(packageName, callback, thisObj, isShowPop)
  if callback == nil then
    callback=nil
  end
  if thisObj == nil then
    thisObj=nil
  end
  if isShowPop == nil then
    isShowPop=false
  end
  if not SubPackageManager.checkNeedLoad(packageName) then
    if callback then
      callback:call(thisObj)
    end
    return
  else
    LogsManager.echo("xd _开始下载分包", packageName, "_____")
    UserInfo.platform:loadSubPackage(packageName, callback, thisObj, isShowPop)
  end
end

function SubPackageManager.checkNeedLoad(packageName)
  if not UserInfo.isSystemMini() then
    return false
  end
  if (UserInfo.isOppo() or UserInfo.isTT()) or UserInfo.isUC() then
    return false
  end
  if not SubPackageManager.canSubpack then
    return false
  end
  if SubPackageManager.getPackStyle(packageName) ~= SubPackageConst.PATH_STYLE_SUBPACK then
    return false
  end
  if SubPackageManager.getLoadStatus(packageName) then
    return false
  end
  return true
end

function SubPackageManager.setLoadStatus(packageName)
  -- [ts2lua]SubPackageManager.subPackLoadData下标访问可能不正确
  SubPackageManager.subPackLoadData[packageName] = true
  -- [ts2lua]SubPackageConst.subPackData下标访问可能不正确
  local filePath = SubPackageConst.subPackData[packageName].path
  FileUtils.insertOneNativeFile(filePath)
end

function SubPackageManager.getLoadStatus(packageName)
  -- [ts2lua]SubPackageManager.subPackLoadData下标访问可能不正确
  return SubPackageManager.subPackLoadData[packageName]
end

function SubPackageManager.getNewAtlasPath(filePath)
  return filePath
end

function SubPackageManager.getTurnPath(path)
  return nil
end

SubPackageManager.loadCacheArr = {};
function SubPackageManager.load(names, callback, thisObj, isInsert)
  if callback == nil then
    callback=nil
  end
  if thisObj == nil then
    thisObj=nil
  end
  if isInsert == nil then
    isInsert=false
  end
  SubPackageManager._initGroupSubpack()
  if not SubPackageManager.canSubpack then
    LogsManager.echo("xd load 分包加载开关已关闭")
    callback and callback:call(thisObj, false)
    return
  end
  if type(names) == "string" then
    if not SubPackageManager.checkNeedLoad(names) then
      callback and callback:call(thisObj, true)
      return
    end
    names = {names}
  end
  if not #names or #names < 1 then
    LogsManager.echo("SubPackageManager load names error:", names)
    callback and callback:call(thisObj, false)
    return
  end
  local params = {names=names, allNum=#names, callback=callback, thisObj=thisObj, curIndex=0}
  local isAllComplete = true
  local i = 0
  repeat
    local tempValue = names[i+1]
    if SubPackageManager.checkNeedLoad(tempValue) then
      isAllComplete = false
    end
    i=i+1
  until not(i < #names)
  if isAllComplete then
    callback and callback:call(thisObj, true)
    return
  end
  if isInsert then
    SubPackageManager.loadCacheArr:splice(0, 0, params)
  else
    table.insert(SubPackageManager.loadCacheArr, params)
  end
  SubPackageManager.checkLoad()
end

function SubPackageManager.insertDynamicSubPack(names, paths)
  if type(names) == "string" then
    -- [ts2lua]SubPackageConst.subPackData下标访问可能不正确
    if not SubPackageConst.subPackData[names] then
      -- [ts2lua]SubPackageConst.subPackData下标访问可能不正确
      SubPackageConst.subPackData[names] = {path=paths, style=SubPackageConst.PATH_STYLE_SUBPACK}
    end
  else
    local i = 0
    repeat
      local name = names[i+1]
      local path = paths[i+1]
      -- [ts2lua]SubPackageConst.subPackData下标访问可能不正确
      if not SubPackageConst.subPackData[name] then
        -- [ts2lua]SubPackageConst.subPackData下标访问可能不正确
        SubPackageConst.subPackData[name] = {path=path, style=SubPackageConst.PATH_STYLE_SUBPACK}
      end
      i=i+1
    until not(i < #names)
  end
end

function SubPackageManager.loadDynamics(names, paths, callback, thisObj, isInsert)
  if callback == nil then
    callback=nil
  end
  if thisObj == nil then
    thisObj=nil
  end
  if isInsert == nil then
    isInsert=false
  end
  SubPackageManager.insertDynamicSubPack(names, paths)
  SubPackageManager.load(names, callback, thisObj, isInsert)
end

function SubPackageManager.checkLoad()
  if SubPackageManager.curLoadInfo then
    return
  end
  if #SubPackageManager.loadCacheArr == 0 then
    return
  end
  local info = SubPackageManager.loadCacheArr:shift()
  SubPackageManager.sureLoad(info)
end

function SubPackageManager.sureLoad(info)
  SubPackageManager.curLoadInfo = info
  local packName = SubPackageManager.curLoadInfo.names[0+1]
  SubPackageManager.loadSubPackage(packName, SubPackageManager.loadNext, SubPackageManager, true)
end

function SubPackageManager.loadNext(isSuc)
  if isSuc == nil then
    isSuc=false
  end
  if not SubPackageManager.curLoadInfo then
    return
  end
  local curIndex = SubPackageManager.curLoadInfo.curIndex
  -- [ts2lua]SubPackageManager.curLoadInfo.names下标访问可能不正确
  local loadName = SubPackageManager.curLoadInfo.names[curIndex]
  LogsManager.echo("yrc loadNext loadName:", loadName, ">>isSuc:", isSuc)
  local allNum = SubPackageManager.curLoadInfo.allNum
  if curIndex >= allNum - 1 then
    local callback = SubPackageManager.curLoadInfo.callback
    local thisObj = SubPackageManager.curLoadInfo.thisObj
    callback and callback:call(thisObj)
    SubPackageManager.curLoadInfo = nil
    SubPackageManager.checkLoad()
  else
    curIndex=curIndex+1
    SubPackageManager.curLoadInfo.curIndex = curIndex
    -- [ts2lua]SubPackageManager.curLoadInfo.names下标访问可能不正确
    local nextName = SubPackageManager.curLoadInfo.names[curIndex]
    SubPackageManager.loadSubPackage(nextName, SubPackageManager.loadNext, SubPackageManager, true)
  end
end

function SubPackageManager.getModelFileStyle(model)
  return SubPackageManager.getPackStyle(model)
end

function SubPackageManager.getSubData(model)
  -- [ts2lua]SubPackageConst.subPackData下标访问可能不正确
  return SubPackageConst.subPackData[model]
end

function SubPackageManager.checkSubModelIsNative(model)
  -- [ts2lua]SubPackageConst.subPackData下标访问可能不正确
  local info = SubPackageConst.subPackData[model]
  if not info then
    return false
  end
  return info.style == SubPackageConst.PATH_STYLE_NATIVE
end

function SubPackageManager.getPackStyle(packName)
  if not FileUtils.isUserWXSource() then
    return SubPackageConst.PATH_STYLE_NATIVE
  end
  -- [ts2lua]SubPackageConst.subPackData下标访问可能不正确
  local packinfo = SubPackageConst.subPackData[packName]
  if not packinfo then
    return SubPackageConst.PATH_STYLE_NATIVE
  end
  return packinfo.style
end

SubPackageManager._groupInfoCache = {spine={}, sound={}, model3d={}};
function SubPackageManager._getGroupInfoByName(name, type, souceGroupArr)
  if not souceGroupArr then
    return nil
  end
  -- [ts2lua]SubPackageManager._groupInfoCache下标访问可能不正确
  local obj = SubPackageManager._groupInfoCache[type]
  -- [ts2lua]obj下标访问可能不正确
  if obj[name] then
    -- [ts2lua]obj下标访问可能不正确
    return obj[name].groupInfo
  end
  -- [ts2lua]obj下标访问可能不正确
  obj[name] = {}
  local i = 0
  repeat
    local groupInfo = souceGroupArr[i+1]
    local child = groupInfo.child
    if child:find(name) ~= -1 then
      -- [ts2lua]obj下标访问可能不正确
      obj[name].groupInfo = groupInfo
      return groupInfo
    end
    i=i+1
  until not(i < #souceGroupArr)
  return nil
end

function SubPackageManager.getSpineGroupInfo(spineName)
  -- [ts2lua]SubPackageConst下标访问可能不正确
  return SubPackageManager._getGroupInfoByName(spineName, "spine", SubPackageConst["spineGroupCfgs"])
end

function SubPackageManager.getSoundGroupInfo(sound)
  -- [ts2lua]SubPackageConst下标访问可能不正确
  return SubPackageManager._getGroupInfoByName(sound, "sound", SubPackageConst["soundGroupCfgs"])
end

function SubPackageManager.getModel3DGroupInfo(model)
  -- [ts2lua]SubPackageConst下标访问可能不正确
  return SubPackageManager._getGroupInfoByName(model, "model3d", SubPackageConst["model3dGroupCfgs"])
end
