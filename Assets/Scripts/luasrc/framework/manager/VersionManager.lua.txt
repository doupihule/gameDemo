require("trycatch")
require("stringutil")
require("framework/common/UserInfo")
require("framework/manager/LogsManager")
require("utils/Global")
require("framework/manager/CacheManager")
require("game/sys/consts/StorageCode")
require("framework/utils/FileUtils")
require("framework/manager/TimerManager")
require("framework/consts/LogsErrorCode")
require("framework/manager/SubPackageManager")
require("game/sys/consts/SubPackageConst")
require("framework/common/GameSwitch")

VersionManager = class('VersionManager')

VersionManager.VERSION_STATUS_NO_UPDATE = 0;
VersionManager.VERSION_STATUS_NEED_UPDATE = 1;
VersionManager.VERSION_STATUS_FORCE_UPDATE = 2;
VersionManager.VERSION_STATUS_SERVER_MAINTAIN = 3;
VersionManager.VERSION_STATUS_VERSION_ROLLBACK = 4;
VersionManager.VERSION_STATUS_VERSION_NOT_EXIST = 5;
VersionManager.VERSION_STATUS_VERSION_DEFAULT_ERROR = 999;
VersionManager.ZIP_3DMODEL_NAME = "3dmodels";
VersionManager.ZIP_MODEL_KEY_VERSION = "version";
VersionManager.ZIP_MODEL_KEY_CONFIG = "json";
VersionManager.ZIP_MODEL_KEY_UICFGS = "uiCfgs";
VersionManager.ZIP_MODEL_KEY_MERGEFILES = "mergefiles";
function VersionManager.__getters.instance()
  if not VersionManager._instance then
    VersionManager._instance = VersionManager()
  end
  return VersionManager._instance
end

function VersionManager:ctor()
  self.versionName = "version.json";
  self.cacheUnZipFilePathMap = {};
  self._modelZipInfo = {};
  self.ingoreCheckGroup = {};
  self._cacheVersion = CacheManager.instance:getGlobalCache(StorageCode.storage_vmsversion) or ""
end

function VersionManager:initVersionData()
  self.versionJsonObj = Laya.Loader:getRes(self.versionName)
  local subPackData = SubPackageConst.subPackData
  for i in pairs(subPackData) do
    local info = subPackData[i+1]
    if i ~= SubPackageConst.packName_json and i ~= SubPackageConst.packName_mergefiles then
      FileUtils.insertOneNativeFile(info.path)
    end
  end
  if not FileUtils.checkIsUseZip() then
    if SubPackageManager.checkSubModelIsNative(SubPackageConst.packName_json) then
      local subCfgs = SubPackageManager.getSubData(SubPackageConst.packName_json)
      FileUtils.insertOneNativeFile(subCfgs.path)
      if subCfgs then
        FileUtils.insertOneNativeFile(subCfgs.path)
      end
    end
    if SubPackageManager.checkSubModelIsNative(SubPackageConst.packName_mergefiles) then
      local subCfgs = SubPackageManager.getSubData(SubPackageConst.packName_mergefiles)
      if subCfgs then
        FileUtils.insertOneNativeFile(subCfgs.path)
      end
    end
    return
  end
  local t1 = Laya.Browser:now()
  local model = nil
  LogsManager.echo("initVersionCost:", Laya.Browser:now() - t1)
  local cfgModelName = VersionManager.ZIP_MODEL_KEY_CONFIG
  self:initOneZipModel(VersionManager.ZIP_MODEL_KEY_CONFIG, "", {VersionManager.ZIP_MODEL_KEY_CONFIG .. "/globalCfgs.json"})
  local fileList = {VersionManager.ZIP_MODEL_KEY_MERGEFILES .. "/mergeJson.bin", VersionManager.ZIP_MODEL_KEY_MERGEFILES .. "/mergeBin.bin"}
  self:initOneZipModel(VersionManager.ZIP_MODEL_KEY_MERGEFILES, "", fileList)
  self:checkClearCacheZip()
end

function VersionManager:deleteOneSubPackVer(path)
  local len = #path
  local obj = self.versionJsonObj
  if not obj then
    return
  end
  local temparr = {}
  for i in pairs(obj) do
    if i:slice(0, len) == path then
      table.insert(temparr, i)
    end
  end
  local ii = 0
  repeat
    -- [ts2lua]temparr下标访问可能不正确
    -- [ts2lua]obj下标访问可能不正确
    obj[temparr[ii]] = nil
    ii=ii+1
  until not(ii < #temparr)
end

function VersionManager:checkClearCacheZip()
  local str = CacheManager.instance:getGlobalCache(StorageCode.storage_zip_file)
  local cacheObj = nil
  if not str or str == "0" then
    cacheObj = {}
  else
    cacheObj = JSON:parse(str)
  end
  local newCacheObj = {}
  local hasVersionChange = false
  local thisObj = self
  for model in pairs(self._modelZipInfo) do
    -- [ts2lua]cacheObj下标访问可能不正确
    local cacheZipName = cacheObj[model]
    local modelInfo = self:getZipModel(model)
    local currenyZipName = modelInfo.zipName
    -- [ts2lua]newCacheObj下标访问可能不正确
    newCacheObj[model] = currenyZipName
    if not cacheZipName then
      hasVersionChange = true
    end
    if cacheZipName and cacheZipName ~= currenyZipName then
      hasVersionChange = true
      local targetZipFolder = FileUtils.getLocalZipCacheFullPath() + cacheZipName .. "/"
      self:tryDeleteTargetFile(targetZipFolder)
    end
  end
  if hasVersionChange then
    str = JSON:stringify(newCacheObj)
    CacheManager.instance:setGlobalCache(StorageCode.storage_zip_file, str)
  else
    LogsManager.echo("_zip文件没有发生变化不需要清理")
  end
end

function VersionManager:tryDeleteTargetFile(targetZipFolder, index)
  if index == nil then
    index=0
  end
  local thisObj = self
  if FileUtils.existsLocalFile(targetZipFolder) then
    try_catch{
      main = function()
        wx:getFileSystemManager():rmdir({dirPath=targetZipFolder, success=function()
          LogsManager.echo("删除zip文件夹成功:", targetZipFolder)
        end
        , fail=function(ee)
          local errorStr = nil
          try_catch{
            main = function()
              errorStr = JSON:stringify(ee)
            end,
            catch = function(e)
              errorStr = ee:toString()
            end
          }
          LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "_删除目录失败,", targetZipFolder, errorStr, "次数:", index)
          if index == 0 then
            LogsManager.echo("_再次尝试删除目标文件")
            TimerManager.instance:add(thisObj.tryDeleteTargetFile, thisObj, 20, 1, false, {targetZipFolder, 1})
          end
        end
        , recursive=true}, true)
      end,
      catch = function(e)
        LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "_尝试移除文件夹失败", e:toString())
      end
    }
  end
end

function VersionManager:getUnZipFilePath(model)
  local modelInfo = self:getZipModel(model)
  return FileUtils.getLocalZipCacheFullPath() + modelInfo.zipPath + modelInfo.unZipFolderName
end

function VersionManager:initOneZipModel(model, path, fileList)
  -- [ts2lua]self._modelZipInfo下标访问可能不正确
  local info = self._modelZipInfo[model]
  if not info then
    -- [ts2lua]self._modelZipInfo下标访问可能不正确
    self._modelZipInfo[model] = {}
    -- [ts2lua]self._modelZipInfo下标访问可能不正确
    info = self._modelZipInfo[model]
  end
  info.model = model
  local fullPath = path + model .. ".zip"
  -- [ts2lua]self.versionJsonObj下标访问可能不正确
  info.zipFile = self.versionJsonObj[fullPath] or fullPath
  info.zipPath = path
  info.zipName = FileUtils.getFileNameByUrl(info.zipFile)
  info.unZipFolderName = FileUtils.getFileNameByUrl(info.zipFile)
  if fileList then
    info.fileList = fileList
  end
end

function VersionManager:getZipModel(model)
  -- [ts2lua]self._modelZipInfo下标访问可能不正确
  if not self._modelZipInfo[model] then
    -- [ts2lua]self._modelZipInfo下标访问可能不正确
    self._modelZipInfo[model] = {fileList={}}
  end
  -- [ts2lua]self._modelZipInfo下标访问可能不正确
  return self._modelZipInfo[model]
end

function VersionManager:versionFileCheck()
  if not FileUtils.isUserWXSource() then
    return
  end
  table.insert(self.ingoreCheckGroup, {"version_" .. Global.version .. ".json"})
  local jsonObj = Laya.Loader:getRes(self.versionName)
  local fileInfoObj = Laya.MiniFileMgr.filesListObj
  local isSendMaxLog = false
  local fileSize = fileInfoObj.fileUsedSize
  if fileSize > 25 * 1024 * 1024 then
    isSendMaxLog = true
  end
  local basePath = Laya.URL.basePath
  local newFileKeyMap = {}
  for i in pairs(jsonObj) do
    local newKey = basePath + jsonObj[i+1]
    -- [ts2lua]newFileKeyMap下标访问可能不正确
    newFileKeyMap[newKey] = true
  end
  local onDeleBack = function(fileName)
    LogsManager.echo("删除资源成功", fileName)
  end
  
  local fileNum = 0
  local fileNameStr = ""
  local platformPath = "/" .. UserInfo.platformId .. "/"
  for ii in pairs(fileInfoObj) do
    -- [ts2lua]newFileKeyMap下标访问可能不正确
    if not newFileKeyMap[ii] then
      if (ii:find(basePath) ~= -1 or ii:find(platformPath) ~= -1) or ii:find("172.16.1") ~= -1 then
        local isIngoreKey = false
        local iii = 0
        repeat
          -- [ts2lua]self.ingoreCheckGroup下标访问可能不正确
          local ingoreKey = self.ingoreCheckGroup[iii]
          if ii:find(basePath + ingoreKey) ~= -1 then
            isIngoreKey = true
          end
          iii=iii+1
        until not(iii < #self.ingoreCheckGroup)
        if not isIngoreKey then
          -- [ts2lua]fileInfoObj下标访问可能不正确
          local info = fileInfoObj[ii]
          if type(info) == "object" then
            LogsManager.echo("删除旧版本资源:", ii)
            Laya.MiniFileMgr:deleteFile("", info.readyUrl, Laya.Handler(nil, onDeleBack, {ii}), info.encoding, info.size)
          end
        else
          LogsManager.echo("忽略删除文件:", ii)
        end
      end
    end
    fileNum=fileNum+1
    if isSendMaxLog then
      fileNameStr = fileNameStr .. "," .. FileUtils.getFileNameByUrl(ii)
    end
  end
  if isSendMaxLog then
    LogsManager.echo("allFileName:", fileNameStr)
    LogsManager.echo("Laya.MiniFileMgr.filesListObj.fileUsedSize:", fileSize, ">fileNum", fileNum)
    LogsManager.errorTag("LayaFileOverSize")
  end
end

function VersionManager.checkIsForceUpdate()
  if UserInfo.isWX() then
    local switchState = GameSwitch.getSwitchState(GameSwitch.SWITCH_FORCE_UPDATE)
    if not switchState or switchState == "0" then
      if UserInfo.isOnIosDevice() then
        LogsManager.echo("ForceUpdate 0 wxios设备关闭了强更")
        return false
      end
    elseif switchState == "2" then
      LogsManager.echo("ForceUpdate 2 wxios和android设备关闭了强更")
      return false
    elseif switchState == "1" then
      if UserInfo.isOnAndroidDevice() then
        LogsManager.echo("ForceUpdate 1 wxandroid设备关闭了强更")
        return false
      end
    end
  end
  LogsManager.echo("ForceUpdate 3  走正常更新流程")
  return VersionManager.versionStatus == VersionManager.VERSION_STATUS_FORCE_UPDATE
end

function VersionManager:get3dModelZipFileName(model)
  -- [ts2lua]self._modelZipInfo下标访问可能不正确
  return self._modelZipInfo[model].zipFile
end

function VersionManager:get3dZipModelName(targetModelPath)
  local keyArr = targetModelPath:split("/")
  return keyArr[1+1]
end

function VersionManager:getModelZipFileName(modelName)
  -- [ts2lua]self._modelZipInfo下标访问可能不正确
  return self._modelZipInfo[modelName].zipFile
end

function VersionManager:checkModelFilesIsRight(modelName, stopByNoFile)
  if stopByNoFile == nil then
    stopByNoFile=false
  end
  -- [ts2lua]self._modelZipInfo下标访问可能不正确
  local modelInfo = self._modelZipInfo[modelName]
  if not modelInfo then
    return false
  end
  local fileList = modelInfo.fileList
  local isRight = true
  local t1 = Laya.Browser:now()
  local i = 0
  repeat
    local sourceName = fileList[i+1]
    -- [ts2lua]self.cacheUnZipFilePathMap下标访问可能不正确
    local fileName = self.cacheUnZipFilePathMap[sourceName]
    if not fileName then
      fileName = self:turnFilePathByModel(sourceName, modelName)
      if not FileUtils.existsLocalFile(fileName) then
        LogsManager.echo("xd 本地不存在这个文件,", sourceName)
        if not FileUtils.existsLocalFile(fileName) then
          isRight = false
        else
          LogsManager.echo("xd 二次判断后本地文件有了,", sourceName)
        end
        if stopByNoFile then
          return false
        end
      else
        -- [ts2lua]self.cacheUnZipFilePathMap下标访问可能不正确
        self.cacheUnZipFilePathMap[sourceName] = fileName
      end
    end
    i=i+1
  until not(i < #fileList)
  LogsManager.echo("xd zip完整性校验,model:", modelName, "文件数量:", #fileList, ",_耗时:", Laya.Browser:now() - t1)
  return isRight
end

function VersionManager:initUnZipFilePath(model)
  local modelInfo = self:getZipModel(model)
  local fileList = modelInfo.fileList
  local isRight = true
  local t1 = Laya.Browser:now()
  local i = 0
  repeat
    local sourceName = fileList[i+1]
    -- [ts2lua]self.cacheUnZipFilePathMap下标访问可能不正确
    if not self.cacheUnZipFilePathMap[sourceName] then
      local fileName = self:turnFilePathByModel(sourceName, model)
      -- [ts2lua]self.cacheUnZipFilePathMap下标访问可能不正确
      self.cacheUnZipFilePathMap[sourceName] = fileName
    end
    i=i+1
  until not(i < #fileList)
end

function VersionManager:deleteOneModel(model)
  -- [ts2lua]self._modelZipInfo下标访问可能不正确
  self._modelZipInfo[model] = nil
end

function VersionManager:turnFilePathByModel(filePath, modelName)
  -- [ts2lua]self._modelZipInfo下标访问可能不正确
  local modelInfo = self._modelZipInfo[modelName]
  local zipFilePath = modelInfo.zipFile
  if filePath:find(modelName) == -1 then
    filePath = modelInfo.unZipFolderName .. "/" .. modelName .. "/" .. filePath
  else
    filePath = filePath:gsub(modelName, modelInfo.unZipFolderName .. "/" .. modelName)
  end
  return FileUtils.getLocalZipCacheFullPath() + filePath
end

function VersionManager.getVirtualUrl(path)
  path = Laya.URL:getAdptedFilePath(path)
  local obj = VersionManager.instance.versionJsonObj
  local cacheUnZipFilePathMap = VersionManager.instance.cacheUnZipFilePathMap
  -- [ts2lua]cacheUnZipFilePathMap下标访问可能不正确
  local cachePath = cacheUnZipFilePathMap[path]
  if cachePath then
    return cachePath
  end
  if obj then
    -- [ts2lua]obj下标访问可能不正确
    local turnPath = obj[path]
    if turnPath then
      return turnPath
    end
  end
  return path
end
