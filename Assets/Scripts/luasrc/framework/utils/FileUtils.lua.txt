require("trycatch")
require("stringutil")
require("framework/manager/LogsManager")
require("framework/common/UserInfo")
require("framework/common/GameSwitch")
require("framework/consts/LogsErrorCode")

FileUtils = class('FileUtils')
function FileUtils:ctor() end
FileUtils.localFileMap = {http[s]*://.*/resource/assets='cache_crc32/assets'};
FileUtils.localZipPath = "zipCache";
FileUtils.tryUnZipTimes = 2;
FileUtils.isUseZipFiles = true;
FileUtils.fs_cache = {};
function FileUtils.needCache(url)
  return nil
end

function FileUtils.isRemotePath(p)
  return nil
end

function FileUtils.turnFileUrlToLocalFulllPath(p)
  return nil
end

function FileUtils.getLocalFilePath(p)
  return nil
end

function FileUtils.getLocalFullPath(p)
  return nil
end

function FileUtils.normailze(p)
  return nil
end

function FileUtils.getRemoteResUrl()
  return nil
end

function FileUtils.getCacheFilePath()
  return nil
end

function FileUtils.getFullFilePath(shortPath)
  return nil
end

function FileUtils.turnVirtualUrl(targetUrl)
  return nil
end

function FileUtils.existsLocalFile(path)
  if not FileUtils.isUserWXSource() then
    return false
  end
  -- [ts2lua]FileUtils.fs_cache下标访问可能不正确
  local cache = FileUtils.fs_cache[path]
  if cache == 0 then
    return false
  elseif cache == 1 then
    return true
  end
  local cachePath = FileUtils.getLocalCacheRootPath()
  if path:find(cachePath) == -1 then
    path = cachePath + path
  end
  local fs = wx:getFileSystemManager()
  local hasPath = false
  try_catch{
    main = function()
      fs:accessSync(path)
      hasPath = true
      -- [ts2lua]FileUtils.fs_cache下标访问可能不正确
      FileUtils.fs_cache[path] = 1
    end,
    catch = function(e)
      -- [ts2lua]FileUtils.fs_cache下标访问可能不正确
      FileUtils.fs_cache[path] = 0
    end
  }
  return hasPath
end

function FileUtils.checkFileHasCache(url)
  return nil
end

function FileUtils.saveFileData(fileName, path, content, encoding)
  if path == nil then
    path=""
  end
  if encoding == nil then
    encoding="utf8"
  end
  local fs = wx:getFileSystemManager()
  local cachePath = FileUtils.getLocalCacheRootPath()
  if path:find(cachePath) == -1 then
    path = cachePath + path
  end
  local hasPath = false
  local makeResult = FileUtils.mkdirsSync(path)
  if not makeResult then
    LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "_saveFileData error")
  end
  local fullPath = path + fileName
  LogsManager.echo("_saveFileData,fullPath:", fullPath, content)
  fs:writeFile({filePath=fullPath, encoding='utf8', data=content, success=function(data) end, fail=function(errormsg)
    LogsManager.echo("saveFileError:", fullPath, errormsg)
  end
  })
end

function FileUtils.makeTargetFilePath(fullPath)
  local dirName = FileUtils.getFilePathByUrl(fullPath)
  FileUtils.mkdirsSync(dirName)
end

function FileUtils.mkdirsSync(p)
  LogsManager.echo("mkdirsSync-----", p)
  local path = p
  local fs = wx:getFileSystemManager()
  local rootPath = FileUtils.getLocalCacheRootPath()
  local index = p:find(rootPath)
  if index ~= -1 then
    p = p:slice(#rootPath, #p)
  end
  if not GameSwitch.checkOnOff(GameSwitch.SWITCH_DISABLE_MAKEDIR) then
    if not FileUtils.existsLocalFile(path) then
      try_catch{
        main = function()
          LogsManager.echo("使用非递归方式创建文件夹", path)
          fs:mkdirSync(path)
          -- [ts2lua]FileUtils.fs_cache下标访问可能不正确
          FileUtils.fs_cache[path] = 1
          LogsManager.echo("使用非递归方式创建文件夹成功", path)
          return true
        end,
        catch = function(e)
          LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "xd 创建文件夹失败:", path, e:toString())
          return false
        end
      }
    end
  else
    if not FileUtils.existsLocalFile(p) then
      local dirs = p:split('/')
      local current = ""
      try_catch{
        main = function()
          LogsManager.echo("使用递归方式创建文件夹", p)
          local i = 0
          repeat
            local dir = dirs[i+1]
            current = current .. dir .. "/"
            if not FileUtils.existsLocalFile(current) then
              local temp = FileUtils.normailzePath(current)
              -- [ts2lua]FileUtils.fs_cache下标访问可能不正确
              FileUtils.fs_cache[temp] = 1
              fs:mkdirSync(rootPath + current)
            end
            i=i+1
          until not(i < #dirs)
          LogsManager.echo("使用递归方式创建文件夹成功", p)
          return true
        end,
        catch = function(e)
          LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "xd 创建文件夹失败:", p, e:toString())
          return false
        end
      }
    end
  end
  return true
end

function FileUtils.normailzePath(p)
  local arr = p:split("/")
  local original = p:split("/")
  for _tmpi, a in pairs(arr) do
    if a == '' or a == nil then
      local index = original:find(a)
      original:splice(index, 1)
    end
  end
  if #original > 0 then
    return original:join('/')
  end
end

function FileUtils.deleteFileByLocalFullPath(url)
  if not FileUtils.isUserWXSource() then
    return
  end
  local fs = wx:getFileSystemManager()
  local hasPath = false
  try_catch{
    main = function()
      fs:accessSync(url)
      hasPath = true
    end,
    catch = function(e)
      LogsManager.echo(">>>>没有此文件>>>>", url)
    end
  }
  if hasPath then
    fs:unlinkSync(url)
    LogsManager.echo("xd_删除文件成功", url)
  end
end

function FileUtils.getLocalFileData(filePath, encoding)
  if encoding == nil then
    encoding="utf8"
  end
  local fs = wx:getFileSystemManager()
  local cachePath = FileUtils.getLocalCacheRootPath()
  if filePath:find(cachePath) == -1 then
    filePath = cachePath + filePath
  end
  if FileUtils.existsLocalFile(filePath) then
    try_catch{
      main = function()
        local resultStr = fs:readFileSync(filePath, encoding)
        if not resultStr then
          LogsManager.echo("__尝试重新读取一次缓存")
          resultStr = fs:readFileSync(filePath, encoding)
          if resultStr then
            LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "第二次重复读取文件成功", resultStr)
          end
        end
        return resultStr
      end,
      catch = function(e)
        LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "getLocalFileData error,path:", filePath, e:toString())
      end
    }
    return nil
  end
  LogsManager.echo("xd not existsLocalFile:", filePath)
  return nil
end

function FileUtils.isUserWXSource()
  return ((((UserInfo.isWX() or UserInfo.isQQGame()) or UserInfo.isTT()) or UserInfo.isOppo()) or UserInfo.isBaidu()) or UserInfo.isVivo()
end

function FileUtils.getLocalCacheRootPath()
  return FileUtils.getEnvCacheRoot() .. "/"
end

function FileUtils.getEnvCacheRoot()
  -- [ts2lua]wx下标访问可能不正确
  return wx["env"].USER_DATA_PATH
end

function FileUtils.getLocalZipCacheFullPath()
  if FileUtils.isUserWXSource() then
    return FileUtils.getLocalCacheRootPath() + FileUtils.localZipPath .. "/"
  end
  return ''
end

function FileUtils.unZipFile(zipName, zipurl, sucessCallBack, errorBack, tryTimes)
  if tryTimes == nil then
    tryTimes=0
  end
  local fileManager = wx:getFileSystemManager()
  local saveFilePath = FileUtils.getFilePathByUrl(zipName)
  local t1 = Laya.Browser:now()
  LogsManager.echo("xd _start unZipFile:", zipName)
  local unzipFail = function(e)
    local str = nil
    try_catch{
      main = function()
        str = JSON:stringify(e)
      end,
      catch = function(eee)
        str = e:toString()
      end
    }
    LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "zipName,", zipName, "解压失败", str)
    tryTimes = tryTimes + 1
    if tryTimes <= FileUtils.tryUnZipTimes then
      FileUtils.unZipFile(zipName, zipurl, sucessCallBack, errorBack, tryTimes)
    else
      if errorBack then
        errorBack:run()
      end
    end
  end
  
  local unZipSucess = function()
    LogsManager.echo("xd unzipFile,name:", zipName, "  CostTime:", Laya.Browser:now() - t1)
    FileUtils.deleteFileByLocalFullPath(zipName)
    if sucessCallBack then
      sucessCallBack:run()
    end
  end
  
  fileManager:unzip({zipFilePath=zipName, targetPath=zipurl, success=unZipSucess, fail=unzipFail})
end

function FileUtils.getFilePathByUrl(fileUrl, isJoin)
  if isJoin == nil then
    isJoin=true
  end
  if fileUrl:slice(#fileUrl - 1, #fileUrl) == "/" then
    LogsManager.echo("_传入的已经是文件夹了", fileUrl)
    if isJoin then
      return fileUrl
    end
    return fileUrl:slice(0, #fileUrl - 1)
  end
  local arr = fileUrl:split("/")
  arr:splice(#arr - 1, 1)
  if #arr == 0 then
    return ""
  end
  local rt = arr:join("/")
  rt = rt .. "/"
  return rt
end

function FileUtils.getFileNameByUrl(fileUrl)
  local arr = fileUrl:split("/")
  -- [ts2lua]arr下标访问可能不正确
  local fileName = arr[#arr - 1]
  return fileName:split(".")[0+1]
end

function FileUtils.checkIsUseZip()
  if UserInfo.isWeb() then
    return false
  end
  return not GameSwitch.checkOnOff(GameSwitch.SWITCH_DISABLE_ZIP)
end

FileUtils.hasInitCacheRoot = false;
function FileUtils.initRootCachePath()
  if FileUtils.hasInitCacheRoot then
    return
  end
  if not FileUtils.isUserWXSource() then
    return
  end
  FileUtils.hasInitCacheRoot = true
  local rootPath = FileUtils.getLocalCacheRootPath()
  if not FileUtils.existsLocalFile(rootPath) then
    LogsManager.warn("xd 本地没有缓存路径-")
    local fs = wx:getFileSystemManager()
    try_catch{
      main = function()
        fs:mkdirSync(rootPath)
      end,
      catch = function(e)
        LogsManager.errorTag(LogsErrorCode.FILE_ERROR, "xd 缓存路径创建失败:", e:toString(), rootPath)
      end
    }
  end
end

function FileUtils.insertOneNativeFile(path)
  if Laya.MiniAdpter then
    local nativefiles = Laya.MiniAdpter.nativefiles
    if nativefiles:find(path) == -1 then
      table.insert(nativefiles, path)
    end
  end
end

function FileUtils.decodeBinAssets(byte)
  local FILE_TYPE_BIN = 1
  local FILE_TYPE_JSON = 2
  local FILE_TYPE_TEXT = 3
  local fileMap = {}
  byte.endian = Laya.Byte.LITTLE_ENDIAN
  local fileNum = byte:readUint32()
  local i = 0
  repeat
    local fileNameLen = 0
    local fileName = ""
    local type = byte:readUint8()
    fileNameLen = byte:readUint8()
    fileName = byte:readUTFBytes(fileNameLen)
    local fileContentLen = byte:readUint32()
    local fileContent = ""
    if type == FILE_TYPE_BIN then
      fileContent = byte:readArrayBuffer(fileContentLen)
    elseif type == FILE_TYPE_JSON then
      fileContent = JSON:parse(byte:readUTFBytes(fileContentLen))
    else
      fileContent = byte:readUTFBytes(fileContentLen)
    end
    -- [ts2lua]fileMap下标访问可能不正确
    if fileMap[type] then
      -- [ts2lua]fileMap下标访问可能不正确
      -- [ts2lua]fileMap[type]下标访问可能不正确
      fileMap[type][fileName] = fileContent
    else
      -- [ts2lua]fileMap下标访问可能不正确
      fileMap[type] = {fileName=fileContent}
    end
    -- [ts2lua]Laya.Loader.preLoadedMap下标访问可能不正确
    Laya.Loader.preLoadedMap[Laya.URL:formatURL(fileName)] = fileContent
    -- [ts2lua]Laya.Loader.preLoadedMap下标访问可能不正确
    Laya.Loader.preLoadedMap[fileName] = fileContent
    i=i+1
  until not(i < fileNum)
  return fileMap
end
