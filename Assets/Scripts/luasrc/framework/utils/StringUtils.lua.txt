




StringUtils = class('StringUtils')
function StringUtils.ScoreRange(score)
  if score > 99999999 then
    return 99999999
  else
    return score
  end
end

function StringUtils.formatTime(time)
  if time < 10 then
    time = "0" .. time
  end
  return time
end

function StringUtils.reprTime(time)
  local h = Math:floor(time / 3600)
  local m = Math:floor(time - 3600 * h / 60)
  local s = time - 3600 * h - 60 * m
  -- [ts2lua]lua中0和空字符串也是true，此处h > 10需要确认
  local sh = (h > 10 and {h} or {"0" .. h})[1]
  -- [ts2lua]lua中0和空字符串也是true，此处m > 10需要确认
  local sm = (m > 10 and {m} or {"0" .. m})[1]
  -- [ts2lua]lua中0和空字符串也是true，此处s > 10需要确认
  local ss = (s > 10 and {s} or {"0" .. s})[1]
  return sh .. ":" .. sm .. ":" .. ss
end

function StringUtils.getCoinStr(coin)
  local coinStr = ""
  local tempCoin = coin
  if BigNumUtils.compare(coin, 10000) then
    local index = 1
    while(BigNumUtils.compare(BigNumUtils.devide(tempCoin, 1000), 1000))
    do
    index=index+1
    tempCoin = BigNumUtils.devide(tempCoin, 1000) .. ""
    end
    if not StringUtils._reducedUnitArr then
      local reducedUnit = GlobalParamsFunc.instance:getGlobalCfgDatas("reducedUnit").string
      StringUtils._reducedUnitArr = reducedUnit:split(",")
    end
    local reducedUnitArr = StringUtils._reducedUnitArr
    if #reducedUnitArr < index - 1 then
      -- [ts2lua]reducedUnitArr下标访问可能不正确
      coinStr = BigNumUtils.devide(coin, BigNumUtils.pow(1000, #reducedUnitArr)) + reducedUnitArr[#reducedUnitArr - 1]
    else
      -- [ts2lua]reducedUnitArr下标访问可能不正确
      local unit = reducedUnitArr[index - 1]
      coinStr = BigNumUtils.devide(coin, BigNumUtils.pow(1000, index), 1) + unit
    end
  else
    coinStr = coin
  end
  return coinStr
end

function StringUtils.getRGBbyHex(hex)
  local index = "0123456789abcdef"
  if hex:substr(0, 1) == "#" then
    hex = hex:substring(1)
  end
  hex = hex:toLowerCase()
  local rgb = {}
  local i = 0
  repeat
    local colorHex = hex:substr(i * 2, 2)
    local colorHigh = colorHex:substr(0, 1)
    local colorLow = colorHex:substr(1, 1)
    local color = index:find(colorHigh) * 16 + index:find(colorLow) / 255
    table.insert(rgb, color)
    i=i+1
  until not(i < 3)
  return rgb
end

function StringUtils.repeatStr(target, n)
  local s = ""
  local i = 0
  repeat
    s = s + target
    i=i+1
  until not(i < n)
  return s
end

function StringUtils.getPaddingStr(str, len, padding, pos)
  if pos == nil then
    pos=true
  end
  str = String(str)
  if #str >= len then
    return str
  end
  if pos then
    return StringUtils.repeatStr(padding, len - #str) + str
  else
    return str + StringUtils.repeatStr(padding, len - #str)
  end
end

function StringUtils.chekHasChinese(str)
  -- [ts2lua]tslua无法自动转换正则表达式，请手动处理。
  local req = /.*[\u4e00-\u9fa5]+.*$/
  if req:test(str) then
    return true
  end
  return false
end

StringUtils._signKey = "0123456789:abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function StringUtils.decodeSign(targetSign)
  local rtStr = ""
  local len = #targetSign
  local singKeyLen = #StringUtils._signKey
  local offNum = GameConsts.GAME_OFFEST % singKeyLen
  local i = 0
  repeat
    local tempStr = targetSign:sub(i)
    if tempStr == "|" then
      rtStr = rtStr .. "|"
    else
      local code = StringUtils._signKey:find(tempStr)
      if code == -1 then
        rtStr = rtStr + tempStr
      else
        code = code - offNum
        if code < 0 then
          code = code + singKeyLen
        end
        rtStr = rtStr + StringUtils._signKey:sub(code)
      end
    end
    i=i+1
  until not(i < len)
  return rtStr
end

function StringUtils.encodeSign(nativeSign)
  local rtStr = ""
  local len = #nativeSign
  local singKeyLen = #StringUtils._signKey
  local offNum = GameConsts.GAME_OFFEST % singKeyLen
  local i = 0
  repeat
    local tempStr = nativeSign:sub(i)
    if tempStr == "|" then
      rtStr = rtStr .. "|"
    else
      local code = StringUtils._signKey:find(tempStr)
      if code == -1 then
        rtStr = rtStr + tempStr
      else
        code = code + offNum
        if code >= singKeyLen then
          code = code - singKeyLen
        end
        rtStr = rtStr + StringUtils._signKey:sub(code)
      end
    end
    i=i+1
  until not(i < len)
  return rtStr
end
