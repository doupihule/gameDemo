





KakuraMessage = class('KakuraMessage')
function KakuraMessage:ctor(...)
  self.defaultAesKey = "ilo24wEFS*^^*2Ewilo24wEFS*^^*2Ew";
  self.headlength = 13;
  self._lastSendTime = 0;
end

KakuraMessage.MESSAGE_NO_ENC = 32;
KakuraMessage.MESSAGE_FIX_ENC_NO_COMPRESS = 11;
KakuraMessage.MESSAGE_DYNAMIC_ENC_NO_COMPRESS = 12;
KakuraMessage.MESSAGE_HAS_ENC = 1;
function KakuraMessage:ctor() end
function KakuraMessage.getInstance()
  if not KakuraMessage._instance then
    KakuraMessage._instance = KakuraMessage.new()
  end
  return KakuraMessage._instance
end

function KakuraMessage:getOneRandomAeskey(num)
  local len = #self.defaultAesKey
  local resultStr = ""
  local i = 0
  repeat
    local index = math.floor(math.random() * len)
    resultStr = resultStr + self.defaultAesKey:substr(index, 1)
    i=i+1
  until not(i < num)
  return resultStr
end

function KakuraMessage:setMessageType(type)
  self._messageType = type
end

function KakuraMessage:addPackage(opcode, requestId, uniqueReqId, sendData, callback, thisObj)
  local pack = KakuraPackage.new()
  pack.opcode = opcode
  pack.requestId = requestId
  pack.len = #sendData * 3
  -- [ts2lua]修改数组长度需要手动处理。
  pack.uniqueReqIdLen = uniqueReqId.length
  pack.uniqueReqId = uniqueReqId
  pack.sendData = sendData
  return pack
end

function KakuraMessage:encode(requestBuffer, aesKey, pack)
  self._lastSendTime = cs.GameUtils.CommonUtil.GetTimeMiniStamp()
  LogsManager.echo(#requestBuffer, "_requestBufferlength")
  local byte = Laya.Byte()
  LogsManager.echo("-------------------------------------------MessageType" .. self._messageType)
  byte.endian = Laya.Byte.LITTLE_ENDIAN
  byte:writeByte(self._messageType)
  local headBody = Laya.Byte()
  headBody.endian = Laya.Byte.LITTLE_ENDIAN
  headBody:writeUint32(pack.opcode)
  headBody:writeUint32(pack.len)
  headBody:writeUint32(pack.requestId)
  headBody:writeByte(pack.uniqueReqIdLen)
  headBody.pos = 0
  if self._messageType == KakuraMessage.MESSAGE_HAS_ENC then
    local headStr = headBody:getCustomString(#headBody)
    local str = headStr + requestBuffer
    local aesStr = self:encrypt(str, aesKey)
    byte:writeUTFBytes(aesStr)
  elseif self._messageType == KakuraMessage.MESSAGE_DYNAMIC_ENC_NO_COMPRESS or self._messageType == KakuraMessage.MESSAGE_FIX_ENC_NO_COMPRESS then
    byte:writeArrayBuffer(headBody.buffer)
    local uniqueReqId = requestBuffer:slice(0, pack.uniqueReqIdLen)
    byte:writeUTFBytes(uniqueReqId)
    requestBuffer = requestBuffer:slice(pack.uniqueReqIdLen)
    local aesStr = self:encryptStr(requestBuffer, aesKey)
    byte:writeUTFBytes(aesStr)
  else
    byte:writeArrayBuffer(headBody.buffer)
    byte:writeUTFBytes(requestBuffer)
  end
  return byte
end

function KakuraMessage:decode(aesKey, byte)
  self._messageType = byte:readUint8()
  LogsManager.echo("-------------------------------------------MessageType" .. self._messageType)
  local decodestr = nil
  local headBody = Laya.Byte()
  if self._messageType == KakuraMessage.MESSAGE_HAS_ENC then
    local aesStr = byte:readUTFBytes(#byte - 1)
    decodestr = self:decrypt(aesStr, aesKey)
    local headStr = decodestr:substr(0, self.headlength)
    headBody.endian = Laya.Byte.LITTLE_ENDIAN
    local length = #headStr
    local i = 0
    repeat
      headBody:writeByte(headStr:charCodeAt(i))
      i=i+1
    until not(i < length)
    headBody.pos = 0
  else
    headBody = byte
  end
  local pack = KakuraPackage.new()
  pack.opcode = headBody:readUint32()
  local len = headBody:readUint32()
  pack.requestId = headBody:readUint32()
  pack.uniqueReqIdLen = headBody:readUint8()
  local data = nil
  local aesBody = ""
  if self._messageType == KakuraMessage.MESSAGE_HAS_ENC then
    if pack.uniqueReqIdLen > 0 then
      pack.uniqueReqId = decodestr:substr(self.headlength, pack.uniqueReqIdLen)
    end
    data = decodestr:substr(self.headlength + pack.uniqueReqIdLen)
  elseif self._messageType == KakuraMessage.MESSAGE_DYNAMIC_ENC_NO_COMPRESS or self._messageType == KakuraMessage.MESSAGE_FIX_ENC_NO_COMPRESS then
    if pack.uniqueReqIdLen > 0 then
      pack.uniqueReqId = headBody:readUTFBytes(pack.uniqueReqIdLen)
    end
    aesBody = headBody:readUTFBytes(headBody.bytesAvailable)
    data = self:decryptAesStr(aesBody, aesKey)
  else
    if pack.uniqueReqIdLen > 0 then
      pack.uniqueReqId = headBody:readUTFBytes(pack.uniqueReqIdLen)
    end
    data = headBody:readUTFBytes(headBody.bytesAvailable)
  end
  pack.len = len
  pack.sendData = data
  if table.findArrValue(LogsManager.ignoreLogs,pack.opcode .. '') == -1 then
    LogsManager.echo("kakura,收到数据：", pack.sendData, pack.requestId, "costTime:", cs.GameUtils.CommonUtil.GetTimeMiniStamp() - self._lastSendTime)
  else
    LogsManager.echo("kakura,pack.opcode:", pack.opcode, pack.requestId, "costTime:", cs.GameUtils.CommonUtil.GetTimeMiniStamp() - self._lastSendTime)
  end
  local jsonData = nil
  try_catch{
    main = function()
      jsonData = TableUtils.safelyJsonParse(pack.sendData)
    end,
    catch = function(e)
      local backStr = "opcode:" .. pack.opcode .. ",len:" .. pack.len .. "reqId:" .. pack.requestId .. ",ureqId:" .. pack.uniqueReqId .. ",body:" .. aesBody .. ",data:" .. pack.sendData
      jsonData = {error={code=ErrorCode.webOffline}}
      local errorInfo = nil
      errorInfo = "server back data is not json \n" .. backStr
      print(errorInfo, "errorInfo")
      LogsManager.sendErrorToPlatform(errorInfo, LogsManager.errorTage_serverError, 10000)
    end
  }
  return jsonData
end

function KakuraMessage:encrypt(word, aesKey)
  return ""
end

function KakuraMessage:encryptStr(word, aesKey)
  local enc = CryptoJS.AES:encrypt(word, CryptoJS.enc.Utf8:parse(aesKey), {mode=CryptoJS.mode.ECB, padding=CryptoJS.pad.Pkcs7})
  local result = enc:toString()
  return result
end

function KakuraMessage:decrypt(word, aesKey)
  return ""
end

function KakuraMessage:decryptAesStr(input, aesKey)
  local result = CryptoJS.AES:decrypt(input, CryptoJS.enc.Utf8:parse(aesKey), {mode=CryptoJS.mode.ECB, padding=CryptoJS.pad.Pkcs7})
  return result:toString(CryptoJS.enc.Utf8)
end

function KakuraMessage:countBufferLen(str)
  local buf = ArrayBuffer.new(#str * 2)
  local bufView = Uint8Array.new(buf)
  local i = 0
  local strLen = #str
  repeat
    bufView[i+1] = str:charCodeAt(i)
    i=i+1
  until not(i < strLen)
  print(">>>>>>>>>u16a.buffer>>>>>>>>>>", bufView.buffer.byteLength)
  print(">>>>>>>>>u16a.buffer>>>>>>>>>>", bufView.byteLength)
  print(">>>>>>>>>u16a.buffer>>>>>>>>>>", #bufView)
  return #bufView
end

function KakuraMessage:byteToString(arr)
  local _arr = arr:getUTFString()
  return _arr
end

function KakuraMessage:stringToByte(str)
  local bytes = Laya.Byte()
  bytes.endian = Laya.Byte.LITTLE_ENDIAN
  local len = nil
  local c = nil
  -- [ts2lua]修改数组长度需要手动处理。
  len = str.length
  local i = 0
  repeat
    c = str:charCodeAt(i)
    if c >= 0x010000 and c <= 0x10FFFF then
      bytes:writeByte(c >> 18 & 0x07 | 0xF0)
      bytes:writeByte(c >> 12 & 0x3F | 0x80)
      bytes:writeByte(c >> 6 & 0x3F | 0x80)
      bytes:writeByte(c & 0x3F | 0x80)
    elseif c >= 0x000800 and c <= 0x00FFFF then
      bytes:writeByte(c >> 12 & 0x0F | 0xE0)
      bytes:writeByte(c >> 6 & 0x3F | 0x80)
      bytes:writeByte(c & 0x3F | 0x80)
    elseif c >= 0x000080 and c <= 0x0007FF then
      bytes:writeByte(c >> 6 & 0x1F | 0xC0)
      bytes:writeByte(c & 0x3F | 0x80)
    else
      bytes:writeByte(c & 0xFF)
    end
    i=i+1
  until not(i < len)
  return bytes
end

function KakuraMessage:ToUTF16(str)
  local result = {}
  local k = 0
  local i = 0
  repeat
    local j = str[i+1]:charCodeAt(0)
    -- [ts2lua]result下标访问可能不正确
    local kBefore = k
    k=k+1
    result[kBefore] = j & 0xFF
    -- [ts2lua]result下标访问可能不正确
    local kBefore = k
    k=k+1
    result[kBefore] = j >> 8
    i=i+1
  until not(i < #str)
  print(">>>>>>>>>ToUTF16>>>>>>>>>>", #result)
  return result
end

function KakuraMessage:ToUTF8(str)
  local result = {}
  local k = 0
  local i = 0
  repeat
    local j = encodeURI(str[i+1])
    if #j == 1 then
      -- [ts2lua]result下标访问可能不正确
      local kBefore = k
      k=k+1
      result[kBefore] = j:charCodeAt(0)
    else
      local bytes = j:split("%")
      local l = 1
      repeat
        -- [ts2lua]result下标访问可能不正确
        local kBefore = k
        k=k+1
        result[kBefore] = parseInt("0x" .. bytes[l+1])
        l=l+1
      until not(l < #bytes)
    end
    i=i+1
  until not(i < #str)
  return result
end
