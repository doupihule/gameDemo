"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InstanceBasic_1 = require("./InstanceBasic");
const InstanceMoveEntity_1 = require("./InstanceMoveEntity");
const InstanceMoveMultyEntity_1 = require("./InstanceMoveMultyEntity");
const BattleFunc_1 = require("../../sys/func/BattleFunc");
const LogsManager_1 = require("../../../framework/manager/LogsManager");
const BattleConst_1 = require("../../sys/consts/BattleConst");
const Equation_1 = require("../../../framework/utils/Equation");
const VectorTools_1 = require("../../../framework/utils/VectorTools");
/**
 * 游戏中所有可以运动的对象的基类
 * 如果需要对instance的view进行拖拽, 那么需要在onTouchMove里面 改变的应该是 this.pos.x 而不能直接去设置myview.x,myView.y
 * 禁止在任何地址直接设置myView的坐标
 */
class InstanceMove extends InstanceBasic_1.default {
    constructor(controller) {
        super(controller);
        //当前运动到点类型 0表示不运动.1 表示运动到目标点
        this.movePointType = 0;
        this.enbleRotate = false;
        this._myState = "stand";
        //是否受重力
        this.gravityAble = false;
        //地面坐标
        this.landPos = 0.1;
        this.isViewShow = true;
        this.gridPos = VectorTools_1.default.createVec3();
        this.speed = VectorTools_1.default.createVec3();
        //定义角速度
        this.rotateSpeed = VectorTools_1.default.createVec3();
        this.addSpeed = VectorTools_1.default.createVec3();
        this.unitVector = VectorTools_1.default.createVec3();
        this.dragForce = VectorTools_1.default.createVec3(1, 1, 1);
        this.blookSpeed = VectorTools_1.default.createVec3(0, 0, 0);
        this.isViewShow = true;
        this.initRotateCtnPos = VectorTools_1.default.createVec3();
    }
    //初始化站立状态(也就是闲置)
    initStand() {
        this._myState = BattleConst_1.default.state_stand;
        this.speed.x = 0;
        this.speed.y = 0;
        this.speed.z = 0;
        //停止旋转
        this.enbleRotate = false;
        // this.setRotateSpeed(0, 0, 0);
    }
    //初始化运动 ,子类可根据这个继承,并改变视图的朝向或者 动作显示
    initMove(x = 0, y = 0, z = 0) {
        this.speed.x = x;
        this.speed.y = y;
        this.speed.z = z;
        this._myState = BattleConst_1.default.state_move;
    }
    //初始化运动 ,子类可根据这个继承,并改变视图的朝向或者 动作显示
    initMove2Stand(x = 0, y = 0, z = 0, scale = 1 / 60) {
        this.speed.x = x;
        this.speed.y = y;
        this.speed.z = z;
        this.addSpeed.x = -x * scale;
        this.addSpeed.y = -y * scale;
        this.addSpeed.z = -z * scale;
        this._myState = BattleConst_1.default.state_move2stand;
    }
    //设置跳跃速度
    initJump(y) {
        this.speed.y = y;
        this._myState = BattleConst_1.default.state_jump;
        this.gravityAble = true;
    }
    //设置角速度
    setRotateSpeed(x, y, z) {
        this.enbleRotate = true;
        this.rotateSpeed.x = x;
        this.rotateSpeed.y = y;
        this.rotateSpeed.z = z;
    }
    //设置速度
    setSpeedByAng(spd, rx, ry, rz) {
        this.initMove(spd * rx, spd * ry, spd * rz);
    }
    //重写执行逻辑函数
    doAiLogical() {
        this.checkMoveEnd();
    }
    //更新速度,根据需要扩展,比如加速度,重力加速度.
    updateSpeed() {
        //如果是静止的不执行减少运算
        if (this._myState == BattleConst_1.default.state_stand) {
            return;
        }
        var preX = this.speed.x;
        this.speed.x = this.setSpeed(this.speed.x, this.addSpeed.x, this.dragForce.x);
        this.speed.y = this.setSpeed(this.speed.y, this.addSpeed.y, this.dragForce.y);
        this.speed.z = this.setSpeed(this.speed.z, this.addSpeed.z, this.dragForce.z);
        if (this._myState == BattleConst_1.default.state_move2stand) {
            if (this.speed.x * preX <= 0) {
                this.speed.x = 0;
                this.speed.y = 0;
                this.speed.z = 0;
                this._myState = BattleConst_1.default.state_stand;
            }
        }
    }
    //设置速度=速度*阻力系数+加速度
    setSpeed(speedSpace, addSpead, force) {
        //阻力
        speedSpace *= force;
        //更新加速度		
        speedSpace += addSpead;
        return speedSpace;
    }
    //重写运动函数 主要是更新坐标
    movePos() {
        //如果是激活旋转的 那么让view的第一去旋转这么多角度
        if (this.enbleRotate) {
            //设置弧度
            this.setRadian(this.rotationRad.x + this.rotateSpeed.x, this.rotationRad.y + this.rotateSpeed.y, this.rotationRad.z + this.rotateSpeed.z);
        }
        //stand状态不执行
        if (this._myState == BattleConst_1.default.state_stand) {
            return;
        }
        this.pos.x += this.speed.x + this.blookSpeed.x;
        this.pos.y += this.speed.y + this.blookSpeed.y;
        this.pos.z += this.speed.z + this.blookSpeed.z;
        //如果坐标小于0 而且是朝地面运动状态  而且是受重力影响的 那么才会去检测落地
        if (this.speed.y < 0 && this.pos.y <= this.landPos && this._myState == BattleConst_1.default.state_move && this.gravityAble) {
            this.onHitLand();
        }
    }
    //着陆了 给子系统重写 比如销毁 或者什么
    onHitLand() {
        this.initStand();
    }
    //运动到目标点 ,只针对平面运动,一般是x,y. movePointType 禁止外部调用
    moveToOnePoint(x, y, z = 0, spd = 0, callFunc = null, thisObj = null, callParams = null, expandParams = null, movePointType = 1) {
        if (!this._moveParams) {
            this._moveParams = new InstanceMoveEntity_1.default(VectorTools_1.default.createVec3(x, y, z));
        }
        if (spd == 0) {
            spd = BattleFunc_1.default.moveSpeed;
        }
        this._moveParams.target.x = x;
        this._moveParams.target.y = y;
        this._moveParams.target.z = z;
        var speed = spd;
        var temp = BattleFunc_1.default.tempPoint;
        //计算目标向量差值
        VectorTools_1.default.subtract(this._moveParams.target, this.pos, temp);
        var distance = VectorTools_1.default.scalarLength(temp);
        //向量归一
        VectorTools_1.default.normalize(temp, this.unitVector);
        //计算速度单位向量 乘以速度绝对值
        VectorTools_1.default.scale(this.unitVector, speed, this._moveParams.initSpeed);
        this._moveParams.moveFrame = 0;
        this._moveParams.callParams = callParams;
        //设置预期运动时间
        this._moveParams.totalFrame = Math.ceil(distance / speed);
        this._moveParams.callFunc = callFunc;
        this._moveParams.thisObj = thisObj;
        this._moveParams.spd = spd;
        // this._moveParams = params;
        this.movePointType = movePointType;
        this.initMove(this._moveParams.initSpeed.x, this._moveParams.initSpeed.y, this._moveParams.initSpeed.z);
        this.checkMoveEnd();
    }
    //根据传递的entity 运动
    moveToOnePointByEntity(enetity, movePointType = 1, isGrid = false) {
        var x = enetity.target.x, y = enetity.target.y;
        if (x == null && enetity.target.y != null) {
            x = enetity.target.x;
            y = enetity.target.y;
        }
        this.moveToOnePoint(x, y, enetity.spd, enetity.callFunc, enetity.thisObj, enetity.callParams, enetity.expandParams, movePointType);
    }
    //按一组点去运动
    // moveToGroupPoints(params:InstanceMoveMultyEntity){
    moveToGroupPoints(pointArr, speed = 0, callFunc = null, thisObj = null, loopParams = null) {
        // this._multyparams = params;
        if (!this._multyparams) {
            this._multyparams = new InstanceMoveMultyEntity_1.default();
        }
        if (speed == 0 || speed == null) {
            speed = BattleFunc_1.default.moveSpeed;
        }
        this._multyparams.initData(pointArr, speed, callFunc, thisObj, loopParams, false);
        var param = this._multyparams.getNextpos();
        if (!param) {
            LogsManager_1.default.errorTag(null, "没有找到当前运动的点");
            return;
        }
        this.moveToOnePointByEntity(param, InstanceMove.moveType_multyPoint, false);
    }
    //按一组网格点运动
    moveToGroupGridPoints(gridArr, speed = 0, callFunc = null, thisObj = null, loopParams = null) {
        // this._multyparams = params;
        if (!this._multyparams) {
            this._multyparams = new InstanceMoveMultyEntity_1.default();
        }
        this._multyparams.initData(gridArr, speed, callFunc, thisObj, loopParams, true);
        var param = this._multyparams.getNextpos();
        if (!param) {
            LogsManager_1.default.errorTag(null, "没有找到当前运动的点");
            return;
        }
        this.moveToOnePointByEntity(param, InstanceMove.moveType_multyPoint, true);
    }
    //判断是否到达终点
    checkMoveEnd() {
        if (this.movePointType == InstanceMove.moveType_none) {
            return;
        }
        //如果是做缓动行为的
        if (this.movePointType == InstanceMove.moveType_tween) {
            this.pos.x = this._myView.x;
            this.pos.y = this._myView.y;
            return;
        }
        this._moveParams.moveFrame++;
        var speedRadio = this._moveParams.getSpeedRadio();
        //根据moveParams 实时刷新速度
        this.speed.x = this._moveParams.initSpeed.x * speedRadio;
        this.speed.y = this._moveParams.initSpeed.y * speedRadio;
        this.speed.z = this._moveParams.initSpeed.z * speedRadio;
        var distance = VectorTools_1.default.distance(this._moveParams.target, this.pos);
        var speedAbs = VectorTools_1.default.scalarLength(this.speed);
        //如果距离小于一个速度绝对值 那么判定到达
        //有需要可以扩展更复杂的行为,比如添加摩擦力,飞跃行为等等
        var whetherEnd = false;
        if (distance < speedAbs) {
            whetherEnd = true;
        }
        if (whetherEnd) {
            this.pos.x = this._moveParams.target.x;
            this.pos.y = this._moveParams.target.y;
            this.pos.z = this._moveParams.target.z;
            if (this.movePointType == InstanceMove.moveType_onePoint) {
                this.overFinalPoint();
            }
            else {
                var param = this._multyparams.getNextpos();
                //如果没有给返回值,直接到达终点
                if (!param) {
                    this.overFinalPoint();
                }
                else {
                    this.onArriveOnePoint();
                    // this._moveParams = param;
                    //重新开始运动到下一个点
                    this.moveToOnePointByEntity(param, InstanceMove.moveType_multyPoint, this._multyparams.isGrid);
                }
            }
        }
        else {
        }
    }
    //到达一个点 ,子类重写,根据需要转身,或者干嘛 ,这个是针对运动到多个点的运动行为判断的 
    onArriveOnePoint() {
    }
    //判断是否有运动类型行为
    checkHasMoveType() {
        if (this.movePointType == InstanceMove.moveType_none) {
            return false;
        }
        return true;
    }
    //到达终点
    overFinalPoint() {
        //初始化变成站立状态,通知子类改变动作行为
        this.initStand();
        this.movePointType = InstanceMove.moveType_none;
        var callBack, thisObj;
        if (this._moveParams) {
            callBack = this._moveParams.callFunc;
            thisObj = this._moveParams.thisObj;
            this._moveParams.reset();
            if (callBack)
                callBack.call(thisObj);
        }
        if (this._multyparams) {
            callBack = this._multyparams.callFunc;
            thisObj = this._multyparams.thisObj;
            this._multyparams.dispose();
            this._multyparams = null;
            if (callBack)
                callBack.call(thisObj);
        }
    }
    //重写realpoS
    realShowView() {
        //如果是做tween缓动行为的
        if (this.movePointType == InstanceMove.moveType_tween) {
            return;
        }
        super.realShowView();
    }
    //晃动相关
    //晃动车 接口预留 
    doShakeInfo() {
        if (!this._shakeInfo) {
            return;
        }
        var info = this._shakeInfo;
        var source = this._shakeSource[info.index];
        if (info.leftFrame > 0) {
            info.leftFrame--;
            if (info.leftFrame == 0) {
                this.resetShakeInfo();
                return;
            }
        }
        var nextSource;
        info.frame++;
        //如果要进入到下一个
        if (info.frame >= source.frame) {
            info.index++;
            info.frame = 0;
            if (info.index == this._shakeSource.length - 1) {
                if (info.leftFrame == 0) {
                    this.resetShakeInfo();
                    return;
                    ;
                }
                else {
                    this.initShakeInfoByIndex(0);
                }
            }
            else {
                this.initShakeInfoByIndex(info.index);
            }
        }
        else {
            nextSource = this._shakeSource[info.index + 1];
            var currentPos = source.pos;
            var nextPos = nextSource.pos;
            var temp = BattleFunc_1.default.tempPoint;
            //计算比例
            var ratio = info.frame / info.length;
            if (currentPos && nextPos) {
                temp.x = Equation_1.default.getPosByRatio(currentPos.x, nextPos.x, ratio);
                temp.y = Equation_1.default.getPosByRatio(currentPos.y, nextPos.y, ratio);
                temp.z = Equation_1.default.getPosByRatio(currentPos.z, nextPos.z, ratio);
                this.setChildViewPos(temp);
            }
            var currentRotation = source.rotation;
            var nextRotation = nextSource.rotation;
            if (currentRotation && nextRotation) {
                temp.x = Equation_1.default.getPosByRatio(currentRotation.x, nextRotation.x, ratio);
                temp.y = Equation_1.default.getPosByRatio(currentRotation.y, nextRotation.y, ratio);
                temp.z = Equation_1.default.getPosByRatio(currentRotation.z, nextRotation.z, ratio);
                this.setChildViewRotation(temp);
            }
        }
    }
    //到达一个点;
    initShakeInfoByIndex(index) {
        this._shakeInfo.index = index;
        this._shakeInfo.frame = 0;
        var info = this._shakeInfo;
        var source = this._shakeSource[info.index];
        info.length = source.frame;
        if (source.pos) {
            this.setChildViewPos(source.pos);
        }
        if (source.rotation) {
            this.setChildViewRotation(source.rotation);
        }
    }
    //重置shakeinfo
    resetShakeInfo() {
        this.setChildViewRotation(BattleFunc_1.default.originPoint);
        this.setChildViewPos(BattleFunc_1.default.originPoint);
        //那么
        this._shakeInfo = null;
    }
    //重置子对象的旋转和坐标为默认值
    resetChildViewRotationAndPos() {
        this.setChildViewRotation(BattleFunc_1.default.originPoint);
        this.setChildViewPos(BattleFunc_1.default.originPoint);
    }
    //设置子对象的旋转
    setChildViewRotation(r) {
        var child = this._myView.getChildAt(0);
        child.set3dRotation(r.x, r.y, r.z);
    }
    //设置子对象的坐标
    setChildViewPos(p) {
        var child = this._myView.getChildAt(0);
        var temp = BattleFunc_1.default.tempPoint4;
        temp.x = p.x + this.initRotateCtnPos.x;
        temp.y = p.x + this.initRotateCtnPos.y;
        temp.z = p.x + this.initRotateCtnPos.z;
        child.set3dPos(p.x + this.initRotateCtnPos.x, p.y + this.initRotateCtnPos.y, p.z + this.initRotateCtnPos.z);
    }
    //设置震动信息totalFrame -1 表示无限循环 0 表示只执行1次
    setShakeInfo(params, totalFrame = 0) {
        this._shakeSource = params;
        this._shakeInfo = {
            index: 0,
            totalFrame: totalFrame,
            leftFrame: totalFrame,
        };
        this.initShakeInfoByIndex(0);
    }
    //显示或者隐藏view
    showOrHideView(value) {
        if (this.isViewShow == value) {
            return;
        }
        this.isViewShow = value;
        this._myView.setActive(value);
    }
}
exports.default = InstanceMove;
//没有运动
InstanceMove.moveType_none = 0;
//运动到一个点
InstanceMove.moveType_onePoint = 1;
//运动到多个点
InstanceMove.moveType_multyPoint = 2;
//做tween缓动行为
InstanceMove.moveType_tween = 3;
InstanceMove.state_stand = "stand";
InstanceMove.state_move = "move";
//# sourceMappingURL=InstanceMove.js.map