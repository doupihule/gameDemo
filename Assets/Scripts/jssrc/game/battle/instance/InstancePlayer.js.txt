"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LogsManager_1 = require("../../../framework/manager/LogsManager");
const BattleFunc_1 = require("../../sys/func/BattleFunc");
const SoundManager_1 = require("../../../framework/manager/SoundManager");
const InstanceRole_1 = require("./InstanceRole");
const GlobalParamsFunc_1 = require("../../sys/func/GlobalParamsFunc");
const MusicConst_1 = require("../../sys/consts/MusicConst");
const VectorTools_1 = require("../../../framework/utils/VectorTools");
const PhysicsTools_1 = require("../../../framework/components/physics/PhysicsTools");
const BattleConst_1 = require("../../sys/consts/BattleConst");
const ViewTools_1 = require("../../../framework/components/ViewTools");
//主角类
class InstancePlayer extends InstanceRole_1.default {
    constructor(controller) {
        super(controller);
        //剩余弹药
        this.leftAmmunition = 10;
        //关卡剩余可使用的子弹数量 -1表示无限
        this.levelLeftAmmunition = 10;
        //最大弹药数量
        this.maxAmmuntion = 0;
        //cd 射击间隔
        this.leftShootCd = 0;
        // 当前连射次数 
        this.currentContinueCount = 0;
        //最大连射次数
        this.maxContinueCount = 0;
        //枪口距离锚点的长度单位米 ,主要用来对子弹的 
        this.shootOffset = 2.3;
        //换弹时间
        this.leftWaitCd = 0;
        //剩余换弹时间
        this.leftChangeBulletTime = 0;
        //连击数 
        this.combCount = 0;
        //最大连击数
        this.maxCombCount = 16;
        //连击次数记录周期(毫秒)
        this.comboRecordCycleFrame = 0;
        //能量
        this.energy = 0;
        //最大能量值
        this.maxEnergy = 100;
        this.rayNoColl = 0;
        this.rayOrigin = VectorTools_1.default.createVec3();
        this.rayDirection = VectorTools_1.default.createVec3();
        this.mainCamera = this.controller.battleCamera;
        this.targetShootPos = VectorTools_1.default.createVec3();
        this.rayHit = PhysicsTools_1.default.createHitInfo();
        this.touchRay = { origin: {}, direction: {} };
        this.bulletSpeed = GlobalParamsFunc_1.default.instance.getGlobalCfgDatas("bulletFlySpeed").num / 1000 || 3;
        // this.bulletSpeed = 0.5;
    }
    //重写设置数据
    setData(data) {
        super.setData(data);
        this._istouchDown = false;
        var baseAttribute = [];
        this.combCount = 0;
        // if (!this.line) {
        this.line = this.controller.line;
        this.line.setActive(false);
        this._myView.addChild(this.line);
        this.line.set3dPos(this.line.x, this.controller.bulletHeight, -this.shootOffset);
        this.initRadian();
        // this.controller.player = this;
        this.collider.collisionGroup = BattleConst_1.default.collion_layer_3;
        this._testCue = ViewTools_1.default.create3DModel("shadow", "Other");
        this.controller.battleCtn.addChild(this._testCue);
    }
    //重置一些属性
    resetAttr() {
    }
    //重写ai函数
    doAiLogical() {
        this.updateCd();
        //判断是否连续射击
        // this.checkAutoShoot();
    }
    //判断是否连续设计
    checkAutoShoot() {
        if (!this._istouchDown) {
            return;
        }
        this.checkShoot();
    }
    //更新一些cd
    updateCd() {
        //发射频率cd
        if (this.leftShootCd > 0) {
            this.leftShootCd--;
        }
        //连射cd
        if (this.leftContinueCd > 0) {
            this.leftContinueCd--;
            if (this.leftContinueCd == 0) {
                //如果超过连续射击间隔了 那么请求当前的连续射击数
                this.currentContinueCount = 0;
                LogsManager_1.default.echo("battle 重置连射次数");
            }
        }
        //如果换弹cd大于0 
        if (this.leftWaitCd > 0) {
            this.leftWaitCd--;
            //如果换弹完毕
            if (this.leftWaitCd == 0) {
                //把弹药补满
                this.changeAmmunition(this.maxAmmuntion - this.leftAmmunition);
                SoundManager_1.default.setSoundVol(0.8, this.cfgsData.reloadSound);
                // SoundManager.playSE(this.cfgsData.reloadSound)
            }
        }
    }
    //开始射击
    onClick() {
    }
    //触摸按下
    onToucheDown(stagex, stagey) {
        this._istouchDown = true;
        this.countGunRotate(stagex, stagey);
        this.line.setActive(true);
        this.checkHit();
    }
    //移动
    onTouchMove(stagex, stagey) {
        this.countGunRotate(stagex, stagey);
    }
    //计算枪的角度 
    countGunRotate(stagex, stagey) {
        //计算射线
        var temp = VectorTools_1.default.createVec2();
        temp.x = stagex;
        temp.y = stagey;
        this.touchRay = this.mainCamera.viewportPointToRay(temp, this.touchRay);
        //计算射线和 游戏平面的交点
        var rt = VectorTools_1.default.intersectsRayAndPlaneRP(this.touchRay, this.controller.gamePlane, this.targetShootPos);
        if (!rt) {
            LogsManager_1.default.errorTag(null, "_为什么这个点和平面没有焦点?....");
        }
        // rt = Equation3d.intersectsRayAndPlaneRP(this.touchRay, this.controller.monsterPlane, temp);
        var angY = Math.PI / 4 + Math.atan2(temp.z - this.pos.z, temp.x - this.pos.x);
        // 这个时候在开始算枪的角度
        var dx = this.targetShootPos.x - this.pos.x;
        var dy = this.targetShootPos.y - this.pos.y;
        var dz = this.targetShootPos.z - this.pos.z;
        this._testCue.set3dPos(this.targetShootPos.x, this.targetShootPos.y, this.targetShootPos.z);
        var ang = Math.atan2(-dx, -dz);
        this.rayOrigin.x = this.pos.x;
        this.rayOrigin.y = this.pos.y + this.line.y;
        this.rayOrigin.z = this.pos.z;
        this.rayDirection.x = dx;
        this.rayDirection.y = 0;
        this.rayDirection.z = dz;
        VectorTools_1.default.normalize(this.rayDirection, this.rayDirection);
        //设置目标角度z
        this.setRadian(0, ang, 0);
        //设置y
        this.checkHit();
        TimerManager.instance.deleteObjUpdate(null, this.checkHit, this);
        TimerManager.instance.registObjUpdate(this.checkHit, this);
    }
    //碰撞检测
    checkHit(tmp) {
        PhysicsTools_1.default.rayCast(this.rayOrigin, this.rayDirection, this.rayHit, 300, BattleConst_1.default.collion_layer_1);
        if (!this.line.isActive())
            return;
        if (this.rayHit.hitInfo.succeeded) {
            var dx = this.rayHit.hitInfo.point.x - this.pos.x;
            var dz = this.rayHit.hitInfo.point.z - this.pos.z;
            this.line.setScale(0.1, Math.sqrt(dx * dx + dz * dz) - this.shootOffset, 0.1);
            this.rayNoColl = 0;
        }
        else {
            if (this.rayNoColl >= 3) {
                this.line.setScale(0.1, 200, 0.1);
            }
            this.rayNoColl++;
        }
    }
    // private lineSprite: Laya.PixelLineSprite3D;
    //触摸结束
    onTouchEnd(stagex, stagey) {
        if (this._istouchDown) {
            this.countGunRotate(stagex, stagey);
            //取消点击
            this._istouchDown = false;
            this.checkHit(1);
            this.line.setActive(false);
            TimerManager.instance.deleteObjUpdate(null, this.checkHit, this);
            this.checkShoot();
        }
    }
    //开始准备射击
    checkShoot() {
        if (this.controller.bulletNum > 0 && !this.controller.battleEnd) {
            this.createBullet([1, 0, 0, this._myView.get3dRotation().y]);
            this.controller.bulletNum--;
            this.controller.battleUi && this.controller.battleUi.refreshBullet();
        }
        else {
            this.controller.bulletArr;
        }
        return;
    }
    //创建子弹
    createBullet(info) {
        var id = info[0];
        //角度偏移
        var angleOffset = info[2];
        if (angleOffset != 0) {
            //角度转弧度
            angleOffset = angleOffset * BattleFunc_1.default.angletoRad;
        }
        var ang = info[3] / BattleFunc_1.default.radtoAngle;
        //计算子弹偏移量
        //X=rand(-10,10)*连射次数*连射稳定参数1/(连射稳定参数2+枪稳定性)
        var offsetx;
        var continueCount = this.currentContinueCount - 1;
        var targetRotation;
        if (continueCount == 0) {
            targetRotation = this.rotationRad.z + angleOffset;
        }
        else {
            // var params = GlobalParamsFunc.instance.getGlobalCfgDatas("stabilityParams").arr;
            // var p1 = Number(params[0]);
            // var p2 = Number(params[1]);
            // var random = RandomUtis.getOneRandomFromArea(-10, 10, BattleFunc.battleRandomIndex, 4)
            // offsetx = random * continueCount * p1 / (p2 + this.stability) / 10000;
            // targetx += offsetx;
            //重新算角度
            var dx = this.targetShootPos.x + 0 - this.pos.x;
            var dy = this.targetShootPos.y - this.pos.y;
            targetRotation = Math.atan2(dy, dx) + angleOffset;
        }
        var cosa = Math.cos(ang);
        var sina = Math.sin(ang);
        var targetx = this.pos.x - sina * this.shootOffset;
        var targetz = this.pos.z - cosa * this.shootOffset;
        // LogsManager.echo("_创建子弹",id,"angle:",targetRotation)
        var bullet = this.controller.createBullet({ id: id });
        bullet.setPos(targetx, this.controller.bulletHeight, targetz);
        bullet.setOwner(this);
        //设置子弹角度
        bullet.setRadian(0, ang, 0);
        //设置子弹速度
        bullet.setSpeedByAng(this.bulletSpeed, -sina, 0, -cosa);
        bullet.setViewScale(12);
        SoundManager_1.default.playSE(MusicConst_1.MusicConst.SOUND_SHOOT);
        var shootEffect;
        if (this.controller.shootEffectArr.length) {
            shootEffect = this.controller.shootEffectArr.pop();
        }
        else {
            shootEffect = this.controller.shootEffect.clone();
        }
        this.controller.activeShootEffectArr.push(shootEffect);
        this.controller.battleCtn.addChild(shootEffect);
        shootEffect.set3dPos(bullet.pos.x, bullet.pos.y - 1.3, bullet.pos.z);
        shootEffect.set3dRotation(bullet.rotation.x, bullet.rotation.y, bullet.rotation.z);
        // shootEffect._transform.setWorldLossyScale(shootEffect.transform.getWorldLossyScale());
        shootEffect.setActive(true);
    }
    //改变弹药数量
    changeAmmunition(value, isInit = false) {
        if (value > 0) {
            if (this.levelLeftAmmunition != -1) {
                if (value > this.levelLeftAmmunition) {
                    value = this.levelLeftAmmunition;
                }
                this.levelLeftAmmunition -= value;
            }
        }
        this.leftAmmunition += value;
        //通知战斗界面刷新显示
        if (!isInit) {
            // this.controller.battleUi.updateAmmunition();
        }
    }
    // //击杀一个怪
    // public onKillMonster(monster: InstanceMonster) {
    //     //连击数+1
    //     this.combCount++;
    //     if (this.combCount > this.maxCombCount) {
    //         this.combCount = this.maxCombCount;
    //     }
    //     this.controller.clearCallBack(this, this.changeCombCount);
    //     //一定时间后重置连击数 ,用这种方式的好处就是不用循环在updateframe里面去计算cd了 ,但是一定要记得清除 
    //     this.controller.setCallBack(this.comboRecordCycleFrame, this.changeCombCount, this, 0);
    //     //计算得分
    //     var comInfo = BattleFunc.instance.getCfgDatas("Combo", String(this.combCount))
    //     var ratio = comInfo.scoreScale / 10000
    //     var ratioEnergy = comInfo.energyScale / 10000
    //     var score = Math.round(monster.baseScore * (1 + ratio))
    //     //计算能量
    //     this.changeEnergy(this.energy + Math.round(monster.baseEnergy * (1 + ratioEnergy)));
    //     //更新分数
    //     this.controller.changeScore(score);
    // }
    //改变能量值
    changeEnergy(value) {
        this.energy = value;
        if (this.energy > this.maxEnergy) {
            this.energy = this.maxEnergy;
        }
    }
    //改变连击数
    changeCombCount(value) {
        this.combCount = value;
    }
}
exports.default = InstancePlayer;
//# sourceMappingURL=InstancePlayer.js.map