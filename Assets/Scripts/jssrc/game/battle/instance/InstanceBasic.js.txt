"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BattleFunc_1 = require("../../sys/func/BattleFunc");
const VectorTools_1 = require("../../../framework/utils/VectorTools");
const UICompConst_1 = require("../../../framework/consts/UICompConst");
/**
 * author:xd
 * 游戏中所有对象的基类. 具备坐标.视图.和刷新 逻辑
 */
class InstanceBasic {
    constructor(controller) {
        this.expendZorder = 0; //扩展的深度排序,特殊情况下 需要设置这个值 保证我的显示在最前面或者最后面
        this.updateCount = 0;
        this.instanceId = 0;
        //视图缩放系数
        this.viewScale = 1;
        this.type = "Basic";
        //拿到游戏控制器和数据
        this.controller = controller;
        this.pos = VectorTools_1.default.createVec3();
        InstanceBasic._instanceCount++;
        this.instanceId = InstanceBasic._instanceCount;
        this.rotation = VectorTools_1.default.createVec3();
        this.rotationRad = VectorTools_1.default.createVec3();
    }
    //设置数据
    setData(data) {
        this._data = data;
        if (data && data.id) {
            this.dataId = data.id;
        }
        //清除自身注册的所有回调 防止因为复用时 还注册了回调导致报错
        this.controller.clearCallBack(this);
    }
    //获取数据
    getData() {
        return this._data;
    }
    //自身数据发生变化
    //changeData 变化的数据 
    //供子类重写
    onDataChange(changeData) {
        //数据发生变化需要刷新视图
        this.updateView();
    }
    //更新视图供子类重写
    updateView() {
    }
    //设置视图
    setView(view, x = 0, y = 0, z = 0, parent = null) {
        if (this._myView != view) {
            this.disposeView();
        }
        this._myView = view;
        this.setPos(x, y, z);
        this.updateView();
        this.collider = this._myView.getComponent(UICompConst_1.default.comp_collider);
    }
    //设置坐标
    setPos(x = 0, y = 0, z = 0) {
        this.pos.x = x;
        this.pos.y = y;
        this.pos.z = z;
        this.realShowView();
    }
    //逐帧刷新函数
    updateFrame() {
        this.updateCount++;
        //这里写一些空函数,供子类重写.
        this.doAiLogical();
        this.updateSpeed();
    }
    updateFrameLater() {
        this.movePos();
        this.realShowView();
    }
    //执行ai逻辑
    doAiLogical() {
    }
    //更新速度
    updateSpeed() {
    }
    //子类重写运动函数
    movePos() {
    }
    //实现坐标
    realShowView() {
        if (!this._myView) {
            return;
        }
        var sp;
        if (!this.rigid) {
            this._myView.set3dPos(this.pos.x, this.pos.y, this.pos.z);
        }
        // this._myView.transform.x = this.pos.x;
        // this._myView.transform.y = this.pos.y;
        // this._myView.transform.z = this.pos.z;
    }
    //创建特效 默认1500帧以后自动缓存 .根据特效长度去定义 
    createEfect(effectName, ofx, ofy, ofz, isFollow, frame, withRotate = false) {
        var eff = this.controller.createEffect({ id: effectName });
        eff.setPos(this.pos.x + ofx, this.pos.y + ofy, this.pos.z + ofz);
        eff.setLastFrame(frame);
        if (withRotate) {
            eff.setRadian(this.rotationRad.x, this.rotationRad.y, this.rotationRad.z);
        }
        if (isFollow) {
            eff.setFollowTarget(this, withRotate, ofx, ofy, ofz);
            //如果是 跟随的 那么需要把他放到刷新数组队列里面去
            this.controller.getAllInstanceArr().push(eff);
        }
        return eff;
    }
    //设置旋转弧度
    setRadian(rx, ry, rz) {
        if (rx != null) {
            this.rotationRad.x = rx;
            rx = rx * BattleFunc_1.default.radtoAngle;
            this.rotation.x = rx;
        }
        if (ry != null) {
            this.rotationRad.y = ry;
            ry = ry * BattleFunc_1.default.radtoAngle;
            this.rotation.y = ry;
        }
        if (ry != null) {
            this.rotationRad.z = rz;
            rz = rz * BattleFunc_1.default.radtoAngle;
            this.rotation.z = rz;
        }
        var childView = this._myView;
        if (!childView) {
            return;
        }
        //设置当前view的角度
        childView.set3dRotation(this.rotation.x, this.rotation.y, this.rotation.z);
    }
    //初始化旋转弧度
    initRadian() {
        var childView = this._myView;
        if (!childView) {
            return;
        }
        //设置当前view的角度
        var viewR = childView.get3dRotation();
        VectorTools_1.default.cloneTo(viewR, this.rotation);
    }
    setViewScale(scale) {
        this.viewScale = scale;
        var childView = this._myView;
        if (!childView) {
            return;
        }
        var tempP = BattleFunc_1.default.tempPoint;
        tempP.x = tempP.y = tempP.z = scale;
        childView.setScale(scale, scale, scale);
    }
    //设置网格坐标
    // setGridPos(x:number,y:number){
    // 	this.gridPos.x = x;
    // 	this.gridPos.y = y;
    // 	var worldPos:{x,y,z} = BattleFunc.instance.getWorldPosByGridPos(x,y);
    // 	this.setPos(worldPos.x,worldPos.y);
    // }
    getView() {
        return this._myView;
    }
    destroyPre() {
    }
    //销毁
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.disposeView();
    }
    //销毁视图对象 如果有特殊销毁.给子类重写,龙骨动画需要手动dispos
    //如果有缓存需求,也可以让子类重写
    disposeView() {
        if (this._myView) {
            this._myView.setActive(false);
            this._myView.dispose();
            this._myView = null;
        }
    }
    //判断是否被销毁
    checkIsDispose() {
        return this._isDisposed;
    }
    //获取缓存id
    getPoolId() {
        return "1";
    }
    //当被设置到缓存里面了 子类重写
    onSetToCache() {
        var view = this._myView;
        if (view) {
            view.setActive(false);
            view.removeSelf();
        }
    }
}
exports.default = InstanceBasic;
InstanceBasic._instanceCount = 0;
//# sourceMappingURL=InstanceBasic.js.map