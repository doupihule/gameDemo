"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const KakuraPackage_1 = require("./KakuraPackage");
class KakuraMessage {
    constructor() {
        this.defaultAesKey = "ilo24wEFS*^^*2Ewilo24wEFS*^^*2Ew";
        //消息头的长度, 不包含messagetype .
        this.headlength = 13;
        this._lastSendTime = 0;
    }
    static get instance() {
        if (!this._instance) {
            this._instance = new KakuraMessage();
        }
        return this._instance;
    }
    //获取一个随机key
    getOneRandomAeskey(num) {
        var len = this.defaultAesKey.length;
        var resultStr = "";
        for (var i = 0; i < num; i++) {
            var index = Math.floor(Math.random() * len);
            resultStr += this.defaultAesKey.substr(index, 1);
        }
        return resultStr;
    }
    setMessageType(type) {
        this._messageType = type;
    }
    addPackage(opcode, requestId, uniqueReqId, sendData, callback, thisObj) {
        var pack = new KakuraPackage_1.default();
        pack.opcode = opcode;
        pack.requestId = (requestId);
        pack.len = sendData.length * 3; //this.countBufferLen(sendData);
        pack.uniqueReqIdLen = uniqueReqId.length;
        pack.uniqueReqId = uniqueReqId;
        pack.sendData = sendData;
        return pack;
    }
    encode(requestBuffer, aesKey, pack) {
        // 单个请求数据包 * PACKAGE * 结构:
        // 	*  _messageType [1 byte]
        //  * OPCODE 请求操作码[4 byte]
        //  * DATA_LENGTH 请求数据长度[4 byte]
        //  * REQUEST_ID 请求序列ID[4 byte]
        //  * uniqueReqIdLen 请求的唯一标识符长度(参考Client.getUniqueRequestId)
        //  * DATA 请求数据 是由 uniqueReqId+ 协议内容拼接起来的(requestBuffer)
        // * 协议采用小端
        return requestBuffer;
    }
    decode(aesKey, byte) {
        return byte;
    }
    encrypt(word, aesKey) {
        return ""; //str;
    }
    encryptStr(word, aesKey) {
        var enc = CryptoJS.AES.encrypt(word, CryptoJS.enc.Utf8.parse(aesKey), {
            mode: CryptoJS.mode.ECB,
            padding: CryptoJS.pad.Pkcs7
        });
        var result = enc.toString();
        return result;
    }
    decrypt(word, aesKey) {
        return "";
    }
    decryptAesStr(input, aesKey) {
        var result = CryptoJS.AES.decrypt(input, CryptoJS.enc.Utf8.parse(aesKey), {
            mode: CryptoJS.mode.ECB,
            padding: CryptoJS.pad.Pkcs7
        });
        return result.toString(CryptoJS.enc.Utf8);
    }
}
exports.default = KakuraMessage;
//32是不加密不加锁 1是加密不压缩
KakuraMessage.MESSAGE_NO_ENC = 32;
KakuraMessage.MESSAGE_FIX_ENC_NO_COMPRESS = 11;
KakuraMessage.MESSAGE_DYNAMIC_ENC_NO_COMPRESS = 12;
KakuraMessage.MESSAGE_HAS_ENC = 1;
